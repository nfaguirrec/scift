!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!                                                                                   !!
!!  This file is part of SciFT project                                               !!
!!  Copyright (c) 2013-2013 Nestor F. Aguirre (nfaguirrec@gmail.com)                 !!
!!                                                                                   !!
!!  Redistribution and use in source and binary forms, with or without               !!
!!  modification, are permitted provided that the following conditions are met:      !!
!!                                                                                   !!
!!  1. Redistributions of source code must retain the above copyright notice, this   !!
!!     list of conditions and the following disclaimer.                              !!
!!  2. Redistributions in binary form must reproduce the above copyright notice,     !!
!!     this list of conditions and the following disclaimer in the documentation     !!
!!     and/or other materials provided with the distribution.                        !!
!!  3. Neither the name of the copyright holders nor the names of its contributors   !!
!!     may be used to endorse or promote products derived from this software         !!
!!     without specific prior written permission.                                    !!
!!                                                                                   !!
!!  The copyright holders provide no reassurances that the source code provided      !!
!!  does not infringe any patent, copyright, or any other intellectual property      !!
!!  rights of third parties.  The copyright holders disclaim any liability to any    !!
!!  recipient for claims brought against recipient by any third party for            !!
!!  infringement of that parties intellectual property rights.                       !!
!!                                                                                   !!
!!  THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND  !!
!!  ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED    !!
!!  WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE           !!
!!  DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE LIABLE FOR  !!
!!  ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES   !!
!!  (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES;     !!
!!  LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND      !!
!!  ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT       !!
!!  (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS    !!
!!  SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.                     !!
!!                                                                                   !!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

#ifndef NFUNCTION3D_H90
#define NFUNCTION3D_H90 1
	
	type, public :: NFunction3D
		type(Grid3D) :: xyzGrid
		__TYPE_VALUE__ , allocatable :: fArray(:,:,:)
		
		contains
			generic :: init => fromGrid3D, fromArrays, fromGrid3DArray, fromFunction, fromFile!, fromFStream
			procedure :: fromGrid3D
			procedure :: fromArrays
			procedure :: fromGrid3DArray
			procedure :: fromFunction
			procedure :: fromFile
! 			procedure :: fromFStream
			generic :: assignment(=) => copyNFunction3D
			generic :: copy => copyNFunction3D
			procedure :: copyNFunction3D
			procedure :: copyFArray
			final :: destroyNFunction3D
			
			procedure :: addition
			procedure :: subtraction
			procedure :: multiplication
			procedure :: division
			procedure :: exponentiation
			
			procedure :: additionFC
			procedure :: subtractionFC
			procedure :: multiplicationFC
			procedure :: divisionFC
			procedure :: exponentiationFC
			
			generic :: operator(+) => addition, additionFC
			generic :: operator(-) => subtraction, subtractionFC
			generic :: operator(*) => multiplication, multiplicationFC
			generic :: operator(/) => division, divisionFC
			generic :: operator(**) => exponentiation, exponentiationFC
! 			
			procedure :: str
			procedure :: show
			procedure :: save
			procedure :: saveN3DF
			procedure :: saveCUBE
			procedure :: saveBLKS
			procedure :: saveProjection1D
			procedure :: saveProjection2D
			procedure :: load => fromFile
			procedure :: checkTypeN3DF
			procedure :: loadN3DF
			procedure :: loadCUBE
			procedure :: loadBLKS
! 			procedure :: toFStream
! 			procedure :: setUnits

			procedure :: set
			procedure :: at
			
			procedure :: x
			procedure :: y
			procedure :: z
			generic :: min => minInCoord, minVec
			procedure :: minInCoord
			procedure :: minVec
			generic :: max => maxInCoord, maxVec
			procedure :: maxInCoord
			procedure :: maxVec
			generic :: stepSize => stepSizeInCoord, stepSizeVec
			procedure :: stepSizeInCoord
			procedure :: stepSizeVec
			procedure :: isEquallyspaced
			procedure :: checkEquallyspaced
			
			generic :: size => ssize
			generic :: nPoints => ssize
			procedure :: ssize
			procedure :: normalize
			procedure :: norm
			
			generic :: expectationValue => expectationValueFromNFunction, expectationValueFromRArray, expectationValueFromCArray
			procedure :: expectationValueFromNFunction
			procedure :: expectationValueFromRArray
			procedure :: expectationValueFromCArray
			
			procedure :: interpolate
			generic :: evaluate => evaluateXYZ, evaluateCoord
			procedure :: evaluateXYZ
			procedure :: evaluateCoord
			
			procedure :: resize
			
			procedure :: checkBox
			generic :: innerProduct => innerProductWithNFunction3D, innerProductWithRArray, innerProductWithCArray
			procedure :: innerProductWithNFunction3D
			procedure :: innerProductWithRArray
			procedure :: innerProductWithCArray
			procedure :: conjugate
			procedure :: absoluteSquare
			procedure :: reducedFunction
			
			__ADD_METHODS__
	end type NFunction3D

	interface
		function prototypeFunction3D( x, y, z ) result( output )
			real(8), intent(in) :: x, y, z
			__TYPE_VALUE__ :: output
		end function prototypeFunction3D
	end interface
	
	integer :: voxelCoeff(64,64) = &
[ &
[ 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], &
[ 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], &
[-3, 3, 0, 0, 0, 0, 0, 0,-2,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], &
[ 2,-2, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], &
[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], &
[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], &
[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-2,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], &
[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2,-2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], &
[-3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-2, 0,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], &
[ 0, 0, 0, 0, 0, 0, 0, 0,-3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-2, 0,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], &
[ 9,-9,-9, 9, 0, 0, 0, 0, 6, 3,-6,-3, 0, 0, 0, 0, 6,-6, 3,-3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 2, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], &
[-6, 6, 6,-6, 0, 0, 0, 0,-3,-3, 3, 3, 0, 0, 0, 0,-4, 4,-2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-2,-2,-1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], &
[ 2, 0,-2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], &
[ 0, 0, 0, 0, 0, 0, 0, 0, 2, 0,-2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], &
[-6, 6, 6,-6, 0, 0, 0, 0,-4,-2, 4, 2, 0, 0, 0, 0,-3, 3,-3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-2,-1,-2,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], &
[ 4,-4,-4, 4, 0, 0, 0, 0, 2, 2,-2,-2, 0, 0, 0, 0, 2,-2, 2,-2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], &
[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], &
[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], &
[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-2,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], &
[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2,-2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], &
[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], &
[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0], &
[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-3, 3, 0, 0, 0, 0, 0, 0,-2,-1, 0, 0, 0, 0, 0, 0], &
[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2,-2, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0], &
[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-2, 0,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], &
[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-2, 0,-1, 0, 0, 0, 0, 0], &
[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9,-9,-9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 3,-6,-3, 0, 0, 0, 0, 6,-6, 3,-3, 0, 0, 0, 0, 4, 2, 2, 1, 0, 0, 0, 0], &
[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-6, 6, 6,-6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-3,-3, 3, 3, 0, 0, 0, 0,-4, 4,-2, 2, 0, 0, 0, 0,-2,-2,-1,-1, 0, 0, 0, 0], &
[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0,-2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], &
[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0,-2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 0], &
[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-6, 6, 6,-6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-4,-2, 4, 2, 0, 0, 0, 0,-3, 3,-3, 3, 0, 0, 0, 0,-2,-1,-2,-1, 0, 0, 0, 0], &
[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4,-4,-4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2,-2,-2, 0, 0, 0, 0, 2,-2, 2,-2, 0, 0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0], &
[-3, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-2, 0, 0, 0,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], &
[ 0, 0, 0, 0, 0, 0, 0, 0,-3, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-2, 0, 0, 0,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], &
[ 9,-9, 0, 0,-9, 9, 0, 0, 6, 3, 0, 0,-6,-3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6,-6, 0, 0, 3,-3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 2, 0, 0, 2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], &
[-6, 6, 0, 0, 6,-6, 0, 0,-3,-3, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-4, 4, 0, 0,-2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-2,-2, 0, 0,-1,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], &
[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-3, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-2, 0, 0, 0,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], &
[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-3, 0, 0, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-2, 0, 0, 0,-1, 0, 0, 0], &
[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9,-9, 0, 0,-9, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 3, 0, 0,-6,-3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6,-6, 0, 0, 3,-3, 0, 0, 4, 2, 0, 0, 2, 1, 0, 0], &
[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-6, 6, 0, 0, 6,-6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-3,-3, 0, 0, 3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-4, 4, 0, 0,-2, 2, 0, 0,-2,-2, 0, 0,-1,-1, 0, 0], &
[ 9, 0,-9, 0,-9, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 3, 0,-6, 0,-3, 0, 6, 0,-6, 0, 3, 0,-3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 2, 0, 2, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], &
[ 0, 0, 0, 0, 0, 0, 0, 0, 9, 0,-9, 0,-9, 0, 9, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, 3, 0,-6, 0,-3, 0, 6, 0,-6, 0, 3, 0,-3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4, 0, 2, 0, 2, 0, 1, 0], &
[-27,27,27,-27,27,-27,-27,27,-18,-9,18, 9,18, 9,-18,-9,-18,18,-9, 9,18,-18, 9,-9,-18,18,18,-18,-9, 9, 9,-9,-12,-6,-6,-3,12, 6, 6, 3,-12,-6,12, 6,-6,-3, 6, 3,-12,12,-6, 6,-6, 6,-3, 3,-8,-4,-4,-2,-4,-2,-2,-1], &
[18,-18,-18,18,-18,18,18,-18, 9, 9,-9,-9,-9,-9, 9, 9,12,-12, 6,-6,-12,12,-6, 6,12,-12,-12,12, 6,-6,-6, 6, 6, 6, 3, 3,-6,-6,-3,-3, 6, 6,-6,-6, 3, 3,-3,-3, 8,-8, 4,-4, 4,-4, 2,-2, 4, 4, 2, 2, 2, 2, 1, 1], &
[-6, 0, 6, 0, 6, 0,-6, 0, 0, 0, 0, 0, 0, 0, 0, 0,-3, 0,-3, 0, 3, 0, 3, 0,-4, 0, 4, 0,-2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-2, 0,-2, 0,-1, 0,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0], &
[ 0, 0, 0, 0, 0, 0, 0, 0,-6, 0, 6, 0, 6, 0,-6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-3, 0,-3, 0, 3, 0, 3, 0,-4, 0, 4, 0,-2, 0, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0,-2, 0,-2, 0,-1, 0,-1, 0], &
[18,-18,-18,18,-18,18,18,-18,12, 6,-12,-6,-12,-6,12, 6, 9,-9, 9,-9,-9, 9,-9, 9,12,-12,-12,12, 6,-6,-6, 6, 6, 3, 6, 3,-6,-3,-6,-3, 8, 4,-8,-4, 4, 2,-4,-2, 6,-6, 6,-6, 3,-3, 3,-3, 4, 2, 4, 2, 2, 1, 2, 1], &
[-12,12,12,-12,12,-12,-12,12,-6,-6, 6, 6, 6, 6,-6,-6,-6, 6,-6, 6, 6,-6, 6,-6,-8, 8, 8,-8,-4, 4, 4,-4,-3,-3,-3,-3, 3, 3, 3, 3,-4,-4, 4, 4,-2,-2, 2, 2,-4, 4,-4, 4,-2, 2,-2, 2,-2,-2,-2,-2,-1,-1,-1,-1], &
[ 2, 0, 0, 0,-2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], &
[ 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0,-2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], &
[-6, 6, 0, 0, 6,-6, 0, 0,-4,-2, 0, 0, 4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-3, 3, 0, 0,-3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-2,-1, 0, 0,-2,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], &
[ 4,-4, 0, 0,-4, 4, 0, 0, 2, 2, 0, 0,-2,-2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2,-2, 0, 0, 2,-2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], &
[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0,-2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0], &
[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 0, 0,-2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0], &
[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-6, 6, 0, 0, 6,-6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-4,-2, 0, 0, 4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-3, 3, 0, 0,-3, 3, 0, 0,-2,-1, 0, 0,-2,-1, 0, 0], &
[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 4,-4, 0, 0,-4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 2, 0, 0,-2,-2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2,-2, 0, 0, 2,-2, 0, 0, 1, 1, 0, 0, 1, 1, 0, 0], &
[-6, 0, 6, 0, 6, 0,-6, 0, 0, 0, 0, 0, 0, 0, 0, 0,-4, 0,-2, 0, 4, 0, 2, 0,-3, 0, 3, 0,-3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-2, 0,-1, 0,-2, 0,-1, 0, 0, 0, 0, 0, 0, 0, 0, 0], &
[ 0, 0, 0, 0, 0, 0, 0, 0,-6, 0, 6, 0, 6, 0,-6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,-4, 0,-2, 0, 4, 0, 2, 0,-3, 0, 3, 0,-3, 0, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0,-2, 0,-1, 0,-2, 0,-1, 0], &
[18,-18,-18,18,-18,18,18,-18,12, 6,-12,-6,-12,-6,12, 6,12,-12, 6,-6,-12,12,-6, 6, 9,-9,-9, 9, 9,-9,-9, 9, 8, 4, 4, 2,-8,-4,-4,-2, 6, 3,-6,-3, 6, 3,-6,-3, 6,-6, 3,-3, 6,-6, 3,-3, 4, 2, 2, 1, 4, 2, 2, 1], &
[-12,12,12,-12,12,-12,-12,12,-6,-6, 6, 6, 6, 6,-6,-6,-8, 8,-4, 4, 8,-8, 4,-4,-6, 6, 6,-6,-6, 6, 6,-6,-4,-4,-2,-2, 4, 4, 2, 2,-3,-3, 3, 3,-3,-3, 3, 3,-4, 4,-2, 2,-4, 4,-2, 2,-2,-2,-1,-1,-2,-2,-1,-1], &
[ 4, 0,-4, 0,-4, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0,-2, 0,-2, 0, 2, 0,-2, 0, 2, 0,-2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0], &
[ 0, 0, 0, 0, 0, 0, 0, 0, 4, 0,-4, 0,-4, 0, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, 2, 0,-2, 0,-2, 0, 2, 0,-2, 0, 2, 0,-2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0], &
[-12,12,12,-12,12,-12,-12,12,-8,-4, 8, 4, 8, 4,-8,-4,-6, 6,-6, 6, 6,-6, 6,-6,-6, 6, 6,-6,-6, 6, 6,-6,-4,-2,-4,-2, 4, 2, 4, 2,-4,-2, 4, 2,-4,-2, 4, 2,-3, 3,-3, 3,-3, 3,-3, 3,-2,-1,-2,-1,-2,-1,-2,-1], &
[ 8,-8,-8, 8,-8, 8, 8,-8, 4, 4,-4,-4,-4,-4, 4, 4, 4,-4, 4,-4,-4, 4,-4, 4, 4,-4,-4, 4, 4,-4,-4, 4, 2, 2, 2, 2,-2,-2,-2,-2, 2, 2,-2,-2, 2, 2,-2,-2, 2,-2, 2,-2, 2,-2, 2,-2, 1, 1, 1, 1, 1, 1, 1, 1] &
]
	
! [ &
! 		[ 1, 0, -3, 2, 0, 0, 0, 0, -3, 0, 9, -6, 2, 0, -6, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -3, 0, 9, -6, 0, 0, 0, 0, 9, 0, -27, 18, -6, 0, 18, -12, 2, 0, -6, 4, 0, 0, 0, 0, -6, 0, 18, -12, 4, 0, -12, 8 ], &
! 		[ 0, 0, 3, -2, 0, 0, 0, 0, 0, 0, -9, 6, 0, 0, 6, -4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -9, 6, 0, 0, 0, 0, 0, 0, 27, -18, 0, 0, -18, 12, 0, 0, 6, -4, 0, 0, 0, 0, 0, 0, -18, 12, 0, 0, 12, -8 ], &
! 		[ 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, -9, 6, -2, 0, 6, -4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -9, 0, 27, -18, 6, 0, -18, 12, 0, 0, 0, 0, 0, 0, 0, 0, 6, 0, -18, 12, -4, 0, 12, -8 ], &
! 		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, -6, 0, 0, -6, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -27, 18, 0, 0, 18, -12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 18, -12, 0, 0, -12, 8 ], &
! 		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, -9, 6, 0, 0, 0, 0, -9, 0, 27, -18, 6, 0, -18, 12, -2, 0, 6, -4, 0, 0, 0, 0, 6, 0, -18, 12, -4, 0, 12, -8 ], &
! 		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, -6, 0, 0, 0, 0, 0, 0, -27, 18, 0, 0, 18, -12, 0, 0, -6, 4, 0, 0, 0, 0, 0, 0, 18, -12, 0, 0, -12, 8 ], &
! 		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, 0, -27, 18, -6, 0, 18, -12, 0, 0, 0, 0, 0, 0, 0, 0, -6, 0, 18, -12, 4, 0, -12, 8 ], &
! 		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 27, -18, 0, 0, -18, 12, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -18, 12, 0, 0, 12, -8 ], &
! 		[ 0, 1, -2, 1, 0, 0, 0, 0, 0, -3, 6, -3, 0, 2, -4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -3, 6, -3, 0, 0, 0, 0, 0, 9, -18, 9, 0, -6, 12, -6, 0, 2, -4, 2, 0, 0, 0, 0, 0, -6, 12, -6, 0, 4, -8, 4 ], &
! 		[ 0, 0, -1, 1, 0, 0, 0, 0, 0, 0, 3, -3, 0, 0, -2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, -3, 0, 0, 0, 0, 0, 0, -9, 9, 0, 0, 6, -6, 0, 0, -2, 2, 0, 0, 0, 0, 0, 0, 6, -6, 0, 0, -4, 4 ], &
! 		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, -6, 3, 0, -2, 4, -2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -9, 18, -9, 0, 6, -12, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, -12, 6, 0, -4, 8, -4 ], &
! 		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -3, 3, 0, 0, 2, -2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, -9, 0, 0, -6, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -6, 6, 0, 0, 4, -4 ], &
! 		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, -6, 3, 0, 0, 0, 0, 0, -9, 18, -9, 0, 6, -12, 6, 0, -2, 4, -2, 0, 0, 0, 0, 0, 6, -12, 6, 0, -4, 8, -4 ], &
! 		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -3, 3, 0, 0, 0, 0, 0, 0, 9, -9, 0, 0, -6, 6, 0, 0, 2, -2, 0, 0, 0, 0, 0, 0, -6, 6, 0, 0, 4, -4 ], &
! 		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, -18, 9, 0, -6, 12, -6, 0, 0, 0, 0, 0, 0, 0, 0, 0, -6, 12, -6, 0, 4, -8, 4 ], &
! 		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -9, 9, 0, 0, 6, -6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, -6, 0, 0, -4, 4 ], &
! 		[ 0, 0, 0, 0, 1, 0, -3, 2, -2, 0, 6, -4, 1, 0, -3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -3, 0, 9, -6, 6, 0, -18, 12, -3, 0, 9, -6, 0, 0, 0, 0, 2, 0, -6, 4, -4, 0, 12, -8, 2, 0, -6, 4 ], &
! 		[ 0, 0, 0, 0, 0, 0, 3, -2, 0, 0, -6, 4, 0, 0, 3, -2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -9, 6, 0, 0, 18, -12, 0, 0, -9, 6, 0, 0, 0, 0, 0, 0, 6, -4, 0, 0, -12, 8, 0, 0, 6, -4 ], &
! 		[ 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 3, -2, 1, 0, -3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, -9, 6, -3, 0, 9, -6, 0, 0, 0, 0, 0, 0, 0, 0, -2, 0, 6, -4, 2, 0, -6, 4 ], &
! 		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -3, 2, 0, 0, 3, -2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, -6, 0, 0, -9, 6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -6, 4, 0, 0, 6, -4 ], &
! 		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, -9, 6, -6, 0, 18, -12, 3, 0, -9, 6, 0, 0, 0, 0, -2, 0, 6, -4, 4, 0, -12, 8, -2, 0, 6, -4 ], &
! 		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, -6, 0, 0, -18, 12, 0, 0, 9, -6, 0, 0, 0, 0, 0, 0, -6, 4, 0, 0, 12, -8, 0, 0, -6, 4 ], &
! 		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -3, 0, 9, -6, 3, 0, -9, 6, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, -6, 4, -2, 0, 6, -4 ], &
! 		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -9, 6, 0, 0, 9, -6, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, -4, 0, 0, -6, 4 ], &
! 		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, -3, 2, 0, 0, 0, 0, -3, 0, 9, -6, 2, 0, -6, 4, -2, 0, 6, -4, 0, 0, 0, 0, 6, 0, -18, 12, -4, 0, 12, -8, 1, 0, -3, 2, 0, 0, 0, 0, -3, 0, 9, -6, 2, 0, -6, 4 ], &
! 		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, -2, 0, 0, 0, 0, 0, 0, -9, 6, 0, 0, 6, -4, 0, 0, -6, 4, 0, 0, 0, 0, 0, 0, 18, -12, 0, 0, -12, 8, 0, 0, 3, -2, 0, 0, 0, 0, 0, 0, -9, 6, 0, 0, 6, -4 ], &
! 		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, -9, 6, -2, 0, 6, -4, 0, 0, 0, 0, 0, 0, 0, 0, -6, 0, 18, -12, 4, 0, -12, 8, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, -9, 6, -2, 0, 6, -4 ], &
! 		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, -6, 0, 0, -6, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -18, 12, 0, 0, 12, -8, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, -6, 0, 0, -6, 4 ], &
! 		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 3, -2, 0, 0, 0, 0, 3, 0, -9, 6, -2, 0, 6, -4, 1, 0, -3, 2, 0, 0, 0, 0, -3, 0, 9, -6, 2, 0, -6, 4 ], &
! 		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -3, 2, 0, 0, 0, 0, 0, 0, 9, -6, 0, 0, -6, 4, 0, 0, 3, -2, 0, 0, 0, 0, 0, 0, -9, 6, 0, 0, 6, -4 ], &
! 		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -3, 0, 9, -6, 2, 0, -6, 4, 0, 0, 0, 0, 0, 0, 0, 0, 3, 0, -9, 6, -2, 0, 6, -4 ], &
! 		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -9, 6, 0, 0, 6, -4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 9, -6, 0, 0, -6, 4 ], &
! 		[ 0, 0, 0, 0, 0, 1, -2, 1, 0, -2, 4, -2, 0, 1, -2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -3, 6, -3, 0, 6, -12, 6, 0, -3, 6, -3, 0, 0, 0, 0, 0, 2, -4, 2, 0, -4, 8, -4, 0, 2, -4, 2 ], &
! 		[ 0, 0, 0, 0, 0, 0, -1, 1, 0, 0, 2, -2, 0, 0, -1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, -3, 0, 0, -6, 6, 0, 0, 3, -3, 0, 0, 0, 0, 0, 0, -2, 2, 0, 0, 4, -4, 0, 0, -2, 2 ], &
! 		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 2, -1, 0, 1, -2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, -6, 3, 0, -3, 6, -3, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2, 4, -2, 0, 2, -4, 2 ], &
! 		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, -1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -3, 3, 0, 0, 3, -3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, -2, 0, 0, -2, 2 ], &
! 		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, -6, 3, 0, -6, 12, -6, 0, 3, -6, 3, 0, 0, 0, 0, 0, -2, 4, -2, 0, 4, -8, 4, 0, -2, 4, -2 ], &
! 		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -3, 3, 0, 0, 6, -6, 0, 0, -3, 3, 0, 0, 0, 0, 0, 0, 2, -2, 0, 0, -4, 4, 0, 0, 2, -2 ], &
! 		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -3, 6, -3, 0, 3, -6, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, -4, 2, 0, -2, 4, -2 ], &
! 		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, -3, 0, 0, -3, 3, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2, 2, 0, 0, 2, -2 ], &
! 		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -2, 1, 0, 0, 0, 0, 0, -3, 6, -3, 0, 2, -4, 2, 0, -2, 4, -2, 0, 0, 0, 0, 0, 6, -12, 6, 0, -4, 8, -4, 0, 1, -2, 1, 0, 0, 0, 0, 0, -3, 6, -3, 0, 2, -4, 2 ], &
! 		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 1, 0, 0, 0, 0, 0, 0, 3, -3, 0, 0, -2, 2, 0, 0, 2, -2, 0, 0, 0, 0, 0, 0, -6, 6, 0, 0, 4, -4, 0, 0, -1, 1, 0, 0, 0, 0, 0, 0, 3, -3, 0, 0, -2, 2 ], &
! 		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, -6, 3, 0, -2, 4, -2, 0, 0, 0, 0, 0, 0, 0, 0, 0, -6, 12, -6, 0, 4, -8, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, -6, 3, 0, -2, 4, -2 ], &
! 		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -3, 3, 0, 0, 2, -2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, -6, 0, 0, -4, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -3, 3, 0, 0, 2, -2 ], &
! 		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 2, -1, 0, 0, 0, 0, 0, 3, -6, 3, 0, -2, 4, -2, 0, 1, -2, 1, 0, 0, 0, 0, 0, -3, 6, -3, 0, 2, -4, 2 ], &
! 		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, 0, 0, 0, 0, -3, 3, 0, 0, 2, -2, 0, 0, -1, 1, 0, 0, 0, 0, 0, 0, 3, -3, 0, 0, -2, 2 ], &
! 		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -3, 6, -3, 0, 2, -4, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, -6, 3, 0, -2, 4, -2 ], &
! 		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, -3, 0, 0, -2, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -3, 3, 0, 0, 2, -2 ], &
! 		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, -3, 2, -2, 0, 6, -4, 1, 0, -3, 2, 0, 0, 0, 0, -2, 0, 6, -4, 4, 0, -12, 8, -2, 0, 6, -4, 0, 0, 0, 0, 1, 0, -3, 2, -2, 0, 6, -4, 1, 0, -3, 2 ], &
! 		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, -2, 0, 0, -6, 4, 0, 0, 3, -2, 0, 0, 0, 0, 0, 0, -6, 4, 0, 0, 12, -8, 0, 0, -6, 4, 0, 0, 0, 0, 0, 0, 3, -2, 0, 0, -6, 4, 0, 0, 3, -2 ], &
! 		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 3, -2, 1, 0, -3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 2, 0, -6, 4, -2, 0, 6, -4, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 3, -2, 1, 0, -3, 2 ], &
! 		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -3, 2, 0, 0, 3, -2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 6, -4, 0, 0, -6, 4, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -3, 2, 0, 0, 3, -2 ], &
! 		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 3, -2, 2, 0, -6, 4, -1, 0, 3, -2, 0, 0, 0, 0, 1, 0, -3, 2, -2, 0, 6, -4, 1, 0, -3, 2 ], &
! 		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -3, 2, 0, 0, 6, -4, 0, 0, -3, 2, 0, 0, 0, 0, 0, 0, 3, -2, 0, 0, -6, 4, 0, 0, 3, -2 ], &
! 		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, -3, 2, -1, 0, 3, -2, 0, 0, 0, 0, 0, 0, 0, 0, -1, 0, 3, -2, 1, 0, -3, 2 ], &
! 		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 3, -2, 0, 0, -3, 2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -3, 2, 0, 0, 3, -2 ], &
! 		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -2, 1, 0, -2, 4, -2, 0, 1, -2, 1, 0, 0, 0, 0, 0, -2, 4, -2, 0, 4, -8, 4, 0, -2, 4, -2, 0, 0, 0, 0, 0, 1, -2, 1, 0, -2, 4, -2, 0, 1, -2, 1 ], &
! 		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 1, 0, 0, 2, -2, 0, 0, -1, 1, 0, 0, 0, 0, 0, 0, 2, -2, 0, 0, -4, 4, 0, 0, 2, -2, 0, 0, 0, 0, 0, 0, -1, 1, 0, 0, 2, -2, 0, 0, -1, 1 ], &
! 		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 2, -1, 0, 1, -2, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, -4, 2, 0, -2, 4, -2, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 2, -1, 0, 1, -2, 1 ], &
! 		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, -1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -2, 2, 0, 0, 2, -2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, -1, 1 ], &
! 		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 2, -1, 0, 2, -4, 2, 0, -1, 2, -1, 0, 0, 0, 0, 0, 1, -2, 1, 0, -2, 4, -2, 0, 1, -2, 1 ], &
! 		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, -2, 2, 0, 0, 1, -1, 0, 0, 0, 0, 0, 0, -1, 1, 0, 0, 2, -2, 0, 0, -1, 1 ], &
! 		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -2, 1, 0, -1, 2, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 2, -1, 0, 1, -2, 1 ], &
! 		[ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, -1, 1, 0, 0, 1, -1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, -1, 0, 0, -1, 1 ] &
! 	]

	contains
	
	!>
	!! @brief Constructor
	!!
	subroutine fromGrid3D( this, xyzGrid )
		class(NFunction3D) :: this 
		type(Grid3D), intent(in) :: xyzGrid
		
		integer :: i
		integer :: err
		
		this.xyzGrid = xyzGrid
		
		if( allocated(this.fArray) ) deallocate(this.fArray)
		allocate( this.fArray(xyzGrid.nPoints(1),xyzGrid.nPoints(2),xyzGrid.nPoints(3)), stat=err )
		
		if( err /= 0 ) then
			call GOptions_error( &
				"Not enought memory to allocate this function", &
				"NFunction3D.fromGrid3D()" &
			)
		end if
		
		this.fArray = 0.0_8
	end subroutine fromGrid3D
	
	!>
	!! @brief Constructor
	!!
	subroutine fromArrays( this, xArray, yArray, zArray, fArray, units, cutoff, fillWithZeros )
		class(NFunction3D) :: this 
		real(8), intent(in) :: xArray(:)
		real(8), intent(in) :: yArray(:)
		real(8), intent(in) :: zArray(:)
		__TYPE_VALUE__, intent(in) :: fArray(:,:,:)
		real(8), optional, intent(in) :: units(2)
		real(8), optional, intent(in) :: cutoff
		logical, optional :: fillWithZeros
		
		integer :: i, j, k
		real(8) :: effUnits(2)
		real(8) :: effCutoff
		logical :: effFillWithZeros
		
		effUnits = [1.0_8, 1.0_8]
		if( present(units) ) effUnits = units
		
		effCutoff = 1d10
		if( present(cutoff) ) effCutoff = cutoff
		
		effFillWithZeros = .false.
		if( present(fillWithZeros) ) effFillWithZeros = fillWithZeros
		
		if( .not. effFillWithZeros ) then
			if( size(xArray) /= size(fArray,dim=1) ) then
				write(*,"(A)") "### ERROR ### NFunction3D.fromArrays: The xArray's size should be equal to fArray's size"
				stop
			end if
			
			if( size(yArray) /= size(fArray,dim=2) ) then
				write(*,"(A)") "### ERROR ### NFunction3D.fromArrays: The yArray's size should be equal to fArray's size"
				stop
			end if
			
			if( size(zArray) /= size(fArray,dim=3) ) then
				write(*,"(A)") "### ERROR ### NFunction3D.fromArrays: The zArray's size should be equal to fArray's size"
				stop
			end if
		end if
		
		call this.xyzGrid.init( xArray, yArray, zArray )
		call this.xyzGrid.setUnits( effUnits(1) )
		
		if( allocated(this.fArray) ) deallocate(this.fArray)
		allocate( this.fArray( size(xArray), size(yArray), size(zArray) ) )
		
!$omp parallel private(k)
!$omp do schedule(dynamic,1)
		do k=1,size(fArray,dim=3); do j=1,size(fArray,dim=2); do i=1,size(fArray,dim=1)
#if __ID_TYPE__ == 0
			this.fArray(i,j,k) = min( max( fArray(i,j,k)*effUnits(2), -effCutoff ), effCutoff )
#elif __ID_TYPE__ == 1
			this.fArray(i,j,k) = fArray(i,j,k)*effUnits(2)
#endif
		end do; end do; end do
!$omp end do nowait
!$omp end parallel

		if( effFillWithZeros ) then
!$omp parallel private(k)
!$omp do schedule(dynamic,1)
			do k=size(fArray,dim=3)+1,size(zArray); do j=size(fArray,dim=2)+1,size(yArray); do i=size(fArray,dim=1)+1,size(xArray)
				this.fArray(i,j,k) = 0.0_8
			end do; end do; end do
!$omp end do nowait
!$omp end parallel
		end if

	end subroutine fromArrays
	
	!>
	!! @brief Constructor
	!!
	subroutine fromGrid3DArray( this, xyzGrid, fArray, units, cutoff, fillWithZeros )
		class(NFunction3D) :: this 
		type(Grid3D), intent(in) :: xyzGrid
		__TYPE_VALUE__, intent(in) :: fArray(:,:,:)
		real(8), optional, intent(in) :: units(2)
		real(8), optional, intent(in) :: cutoff
		logical, optional :: fillWithZeros
		
		integer :: i, j, k
		real(8) :: effUnits(2)
		real(8) :: effCutoff
		logical :: effFillWithZeros
		
		effUnits = [1.0_8, 1.0_8]
		if( present(units) ) effUnits = units
		
		effCutoff = 1d10
		if( present(cutoff) ) effCutoff = cutoff
		
		effFillWithZeros = .false.
		if( present(fillWithZeros) ) effFillWithZeros = fillWithZeros
		
		this.xyzGrid = xyzGrid
		call this.xyzGrid.setUnits( effUnits(1) )
		
		if( .not. effFillWithZeros ) then
			if( xyzGrid.nPoints(1) /= size(fArray,dim=1) ) then
				write(*,"(A)") "### ERROR ### NFunction3D.fromArrays: The xArray's size should be equal to fArray's size"
				stop
			end if
			
			if( xyzGrid.nPoints(2) /= size(fArray,dim=2) ) then
				write(*,"(A)") "### ERROR ### NFunction3D.fromArrays: The yArray's size should be equal to fArray's size"
				stop
			end if
			
			if( xyzGrid.nPoints(3) /= size(fArray,dim=3) ) then
				write(*,"(A)") "### ERROR ### NFunction3D.fromArrays: The zArray's size should be equal to fArray's size"
				stop
			end if
		end if
		
		if( allocated(this.fArray) ) deallocate(this.fArray)
		allocate( this.fArray(xyzGrid.nPoints(1),xyzGrid.nPoints(2),xyzGrid.nPoints(3)) )
		
!$omp parallel private(k)
!$omp do schedule(dynamic,1)
		do k=1,xyzGrid.nPoints(3); do j=1,xyzGrid.nPoints(2); do i=1,xyzGrid.nPoints(1)
#if __ID_TYPE__ == 0
			this.fArray(i,j,k) = min( max( fArray(i,j,k)*effUnits(2), -effCutoff ), effCutoff )
#elif __ID_TYPE__ == 1
			this.fArray(i,j,k) = fArray(i,j,k)*effUnits(2)
#endif
		end do; end do; end do
!$omp end do nowait
!$omp end parallel

		if( effFillWithZeros ) then
!$omp parallel private(k)
!$omp do schedule(dynamic,1)
			do k=xyzGrid.nPoints(3)+1,size(fArray,dim=3); do j=xyzGrid.nPoints(2)+1,size(fArray,dim=2); do i=xyzGrid.nPoints(1)+1,size(fArray,dim=1)
				this.fArray(i,j,k) = 0.0_8
			end do; end do; end do
!$omp end do nowait
!$omp end parallel
		end if
		
	end subroutine fromGrid3DArray
	
	!>
	!! @brief Constructor
	!!
! 	subroutine fromFunction( this, xyzGrid, func, units )
! 		class(NFunction3D), target :: this 
! 		type(Grid3D), target, intent(in) :: xyzGrid
! 		procedure(prototypeFunction3D) :: func
! 		real(8), optional, intent(in) :: units(2)
! 		
! 		integer :: i, j, k
! 		real(8) :: effUnits(2)
! 		integer :: nx, ny, nz
! 		
! #ifdef _OPENMP
! 		real(8), pointer :: x(:), y(:), z(:)
! 		__TYPE_VALUE__, pointer :: fArray(:,:,:)
! #endif
! 		
! 		if( present(units) ) then
! 			effUnits = units
! 		else
! 			effUnits = [1.0_8, 1.0_8]
! 		end if
! 		
! 		this.xyzGrid = xyzGrid
! 		call this.xyzGrid.setUnits( effUnits(1) )
! 		
! 		nx = this.xyzGrid.nPoints(1)
! 		ny = this.xyzGrid.nPoints(2)
! 		nz = this.xyzGrid.nPoints(3)
! 		
! 		if( allocated(this.fArray) ) deallocate(this.fArray)
! 		allocate( this.fArray(nx,ny,nz) )
! 		
! #ifdef _OPENMP
! 		x => xyzGrid.component(1).data
! 		y => xyzGrid.component(2).data
! 		z => xyzGrid.component(3).data
! 		fArray => this.fArray
! 		
! 		!$omp parallel do shared(fArray,x,y,z,effUnits) private(k)
! 		do k=1,nz; do j=1,ny; do i=1,nx
! 			fArray(i,j,k) = func( x(i), y(j), z(k) )*effUnits(2)
! 		end do; end do; end do
! 		!$omp end parallel do
! 		
! 		nullify( x, y, z, fArray )
! #else
! ! 		NFunction3D_forall( k, 1, nx, j, 1, ny, i, 1, nz )
! 		do k=1,nz; do j=1,ny; do i=1,nx
! 			this.fArray(i,j,k) = func( xyzGrid.x(i), xyzGrid.y(j), xyzGrid.z(k) )*effUnits(2)
! 		end do; end do; end do
! ! 		NFunction3D_endforall
! #endif
! 	end subroutine fromFunction
	
	!>
	!! @brief Constructor
	!!
	subroutine fromFunction( this, xyzGrid, func, units, cutoff )
		class(NFunction3D), target :: this 
		type(Grid3D), target, intent(in) :: xyzGrid
		procedure(prototypeFunction3D) :: func
		real(8), optional, intent(in) :: units(2)
		real(8), optional, intent(in) :: cutoff
		
		integer :: i, j, k
		real(8) :: effUnits(2)
		real(8) :: effCutoff
		integer :: nx, ny, nz
		
		effUnits = [1.0_8, 1.0_8]
		if( present(units) ) effUnits = units
		
		effCutoff = 1d10
		if( present(cutoff) ) effCutoff = cutoff
		
		this.xyzGrid = xyzGrid
		
		call this.xyzGrid.setUnits( effUnits(1) )
		
		nx = this.xyzGrid.nPoints(1)
		ny = this.xyzGrid.nPoints(2)
		nz = this.xyzGrid.nPoints(3)
		
		if( allocated(this.fArray) ) deallocate(this.fArray)
		allocate( this.fArray(nx,ny,nz) )
		
!@todo Esto aparentemente no funciona porque no se puede compartir la funcion func, verificar con wpp -i harmonicKt.wpp
! ! ! !$omp parallel
! ! ! !$omp do
		do k=1,nz; do j=1,ny; do i=1,nx
#if __ID_TYPE__ == 0
			this.fArray(i,j,k) = min( max( func( xyzGrid.x(i), xyzGrid.y(j), xyzGrid.z(k) )*effUnits(2), -effCutoff ), effCutoff )
#elif __ID_TYPE__ == 1
			this.fArray(i,j,k) = func( xyzGrid.x(i), xyzGrid.y(j), xyzGrid.z(k) )*effUnits(2)
#endif
		end do; end do; end do
! ! ! !$omp end parallel
	end subroutine fromFunction
	
	!>
	!! @brief Reads from a file
	!!
	subroutine fromFile( this, fileName, format, cutoff )
		class(NFunction3D) :: this
		character(*), optional, intent(in) :: fileName
		integer, optional, intent(in) :: format
		real(8), optional, intent(in) :: cutoff
		
		integer :: effFormat
		
		character(100), allocatable :: tokens(:)
		character(100) :: extension
		
		if( present(cutoff) ) stop "### ERROR ### NFunction3D.fromFile: cutoff option is not implemented yet"
		
		effFormat = AUTO_FORMAT
		if( present(format) ) effFormat = format
		
		select case ( effFormat )
			case( AUTO_FORMAT )
				call FString_split( fileName, tokens, "." )
				extension = ""
				if( size( tokens ) > 1 ) extension = trim(tokens(size(tokens)))
				deallocate( tokens )
				
				if( trim(extension) == "n3df" ) then
					call this.loadN3DF( fileName )
				else if( trim(extension) == "cube" ) then
					call this.loadCUBE( fileName, CUBE_FORMAT )
				else if( trim(extension) == "rcube" ) then
					call this.loadCUBE( fileName, RCUBE_FORMAT )
				else if( trim(extension) == "icube" ) then
					call this.loadCUBE( fileName, ICUBE_FORMAT )
				else if( trim(extension) == "blks" ) then
					call this.loadBLKS( fileName )
				else
					call GOptions_error( &
						"Unknown format file (AUTO_FORMAT). fileName = "//trim(fileName), &
						"NFunction3D.fromFile(extension="//trim(extension)//")" &
					)
				end if
			case( N3DF_FORMAT )
				call this.loadN3DF( fileName )
			case( CUBE_FORMAT )
				call this.loadCUBE( fileName, CUBE_FORMAT )
			case( RCUBE_FORMAT )
				call this.loadCUBE( fileName, RCUBE_FORMAT )
			case( ICUBE_FORMAT )
				call this.loadCUBE( fileName, ICUBE_FORMAT )
			case( BLKS_FORMAT )
				call this.loadBLKS( fileName )
			case default
				write(6,*) "### ERROR ### NFunction3D.fromFile(). The format is not supported (", effFormat, ")"
				stop
		end select
	end subroutine fromFile
	
	!>
	!! @brief Copy constructor
	!!
	subroutine copyNFunction3D( this, other )
		class(NFunction3D), intent(inout) :: this
		class(NFunction3D), intent(in) :: other
		
		integer :: i, j, k
		
		this.xyzGrid = other.xyzGrid
		
		if( allocated(this.fArray) ) deallocate( this.fArray )
		allocate( this.fArray(other.ssize(1),other.ssize(2),other.ssize(3)) )
		
! 		this.fArray = other.fArray
		
!$omp parallel private(k)
!$omp do schedule(dynamic,1)
		do k=1,other.ssize(3); do j=1,other.ssize(2); do i=1,other.ssize(1)
			this.fArray(i,j,k) = other.fArray(i,j,k)
		end do; end do; end do
!$omp end do nowait
!$omp end parallel
	end subroutine copyNFunction3D
	
	!>
	!! @brief Copy constructor
	!!
	subroutine copyFArray( this, other )
		class(NFunction3D), intent(inout) :: this
		class(NFunction3D), intent(in) :: other
		
		integer :: i, j, k
		
!$omp parallel private(k)
!$omp do schedule(dynamic,1)
		do k=1,other.ssize(3); do j=1,other.ssize(2); do i=1,other.ssize(1)
			this.fArray(i,j,k) = other.fArray(i,j,k)
		end do; end do; end do
!$omp end do nowait
!$omp end parallel
	end subroutine copyFArray
	
	!>
	!! @brief Destructor
	!!
	subroutine destroyNFunction3D( this )
		type(NFunction3D) :: this
		
		if( allocated(this.fArray) ) deallocate( this.fArray )
	end subroutine destroyNFunction3D
	
	!>
	!! @brief
	!!
	function addition( this, other ) result( output )
		class(NFunction3D), intent(in) :: this
		class(NFunction3D), intent(in) :: other
		type(NFunction3D) :: output
		
		integer :: i, j, k
		
		if( this.nPoints(1) /= other.nPoints(1) .or. &
		    this.nPoints(2) /= other.nPoints(2) .or. &
		    this.nPoints(3) /= other.nPoints(3) ) then
			write(*,*) "## ERROR ## the Grids have not the same size"
			stop
		end if
		
		output = this
! 		output.fArray = this.fArray + other.fArray

!$omp parallel private(k)
!$omp do schedule(dynamic,1)
		do k=1,this.nPoints(3); do j=1,this.nPoints(2); do i=1,this.nPoints(1)
			output.fArray(i,j,k) = this.fArray(i,j,k) + other.fArray(i,j,k)
		end do; end do; end do
!$omp end do nowait
!$omp end parallel
	end function addition
	
	!>
	!! @brief
	!!
	function additionFC( this, constant ) result( output )
		class(NFunction3D), intent(in) :: this
		real(8), intent(in) :: constant
		type(NFunction3D) :: output
		
		integer :: i, j, k
		
		output = this
! 		output.fArray = this.fArray+constant

!$omp parallel private(k)
!$omp do schedule(dynamic,1)
		do k=1,this.nPoints(3); do j=1,this.nPoints(2); do i=1,this.nPoints(1)
			output.fArray(i,j,k) = this.fArray(i,j,k) + constant
		end do; end do; end do
!$omp end do nowait
!$omp end parallel
	end function additionFC
	
	!>
	!! @brief
	!!
	function subtraction( this, other ) result( output )
		class(NFunction3D), intent(in) :: this
		type(NFunction3D), intent(in) :: other
		type(NFunction3D) :: output
		
		integer :: i, j, k
		
		if( this.nPoints(1) /= other.nPoints(1) .or. &
		    this.nPoints(2) /= other.nPoints(2) .or. &
		    this.nPoints(3) /= other.nPoints(3) ) then
			write(*,*) "## ERROR ## the Grids have not the same size"
			stop
		end if
		
		output = this
! 		output.fArray = this.fArray - other.fArray

!$omp parallel private(k)
!$omp do schedule(dynamic,1)
		do k=1,this.nPoints(3); do j=1,this.nPoints(2); do i=1,this.nPoints(1)
			output.fArray(i,j,k) = this.fArray(i,j,k) - other.fArray(i,j,k)
		end do; end do; end do
!$omp end do nowait
!$omp end parallel
	end function subtraction
	
	!>
	!! @brief
	!!
	function subtractionFC( this, constant ) result( output )
		class(NFunction3D), intent(in) :: this
		real(8), intent(in) :: constant
		type(NFunction3D) :: output
		
		integer :: i, j, k
		
		output = this
! 		output.fArray = this.fArray-constant

!$omp parallel private(k)
!$omp do schedule(dynamic,1)
		do k=1,this.nPoints(3); do j=1,this.nPoints(2); do i=1,this.nPoints(1)
			output.fArray(i,j,k) = this.fArray(i,j,k) - constant
		end do; end do; end do
!$omp end do nowait
!$omp end parallel
	end function subtractionFC
	
	!>
	!! @brief
	!!
	function multiplication( this, other ) result( output )
		class(NFunction3D), intent(in) :: this
		type(NFunction3D), intent(in) :: other
		type(NFunction3D) :: output
		
		integer :: i, j, k
		
		if( this.nPoints(1) /= other.nPoints(1) .or. &
		    this.nPoints(2) /= other.nPoints(2) .or. &
		    this.nPoints(3) /= other.nPoints(3) ) then
			write(*,*) "## ERROR ## the Grids have not the same size"
			stop
		end if
		
		output = this
		
! 		output.fArray = this.fArray*other.fArray

!$omp parallel private(k)
!$omp do schedule(dynamic,1)
		do k=1,this.nPoints(3); do j=1,this.nPoints(2); do i=1,this.nPoints(1)
			output.fArray(i,j,k) = this.fArray(i,j,k)*other.fArray(i,j,k)
		end do; end do; end do
!$omp end do nowait
!$omp end parallel
	end function multiplication
	
	!>
	!! @brief
	!!
	function multiplicationFC( this, constant ) result( output )
		class(NFunction3D), intent(in) :: this
		real(8), intent(in) :: constant
		type(NFunction3D) :: output
		
		integer :: i, j, k
		
		output = this
! 		output.fArray = this.fArray*constant

!$omp parallel private(k)
!$omp do schedule(dynamic,1)
		do k=1,this.nPoints(3); do j=1,this.nPoints(2); do i=1,this.nPoints(1)
			output.fArray(i,j,k) = this.fArray(i,j,k)*constant
		end do; end do; end do
!$omp end do nowait
!$omp end parallel
	end function multiplicationFC
	
	!>
	!! @brief
	!!
	function division( this, other ) result( output )
		class(NFunction3D), intent(in) :: this
		type(NFunction3D), intent(in) :: other
		type(NFunction3D) :: output
		
		integer :: i, j, k
		
		if( this.nPoints(1) /= other.nPoints(1) .or. &
		    this.nPoints(2) /= other.nPoints(2) .or. &
		    this.nPoints(3) /= other.nPoints(3) ) then
			write(*,*) "## ERROR ## the Grids have not the same size"
			stop
		end if
		
		output = this
! 		output.fArray = this.fArray/other.fArray

!$omp parallel private(k)
!$omp do schedule(dynamic,1)
		do k=1,this.nPoints(3); do j=1,this.nPoints(2); do i=1,this.nPoints(1)
			output.fArray(i,j,k) = this.fArray(i,j,k)/other.fArray(i,j,k)
		end do; end do; end do
!$omp end do nowait
!$omp end parallel
	end function division
	
	!>
	!! @brief
	!!
	function divisionFC( this, constant ) result( output )
		class(NFunction3D), intent(in) :: this
		real(8), intent(in) :: constant
		type(NFunction3D) :: output
		
		integer :: i, j, k
		
		output = this
! 		output.fArray = this.fArray/constant

!$omp parallel private(k)
!$omp do schedule(dynamic,1)
		do k=1,this.nPoints(3); do j=1,this.nPoints(2); do i=1,this.nPoints(1)
			output.fArray(i,j,k) = this.fArray(i,j,k)/constant
		end do; end do; end do
!$omp end do nowait
!$omp end parallel
	end function divisionFC
	
	!>
	!! @brief
	!!
	function exponentiation( this, other ) result( output )
		class(NFunction3D), intent(in) :: this
		type(NFunction3D), intent(in) :: other
		type(NFunction3D) :: output
		
		integer :: i, j, k
		
		if( this.nPoints(1) /= other.nPoints(1) .or. &
		    this.nPoints(2) /= other.nPoints(2) .or. &
		    this.nPoints(3) /= other.nPoints(3) ) then
			write(*,*) "## ERROR ## the Grids have not the same size"
			stop
		end if
		
		output = this
! 		output.fArray = this.fArray**other.fArray

!$omp parallel private(k)
!$omp do schedule(dynamic,1)
		do k=1,this.nPoints(3); do j=1,this.nPoints(2); do i=1,this.nPoints(1)
			output.fArray(i,j,k) = this.fArray(i,j,k)**other.fArray(i,j,k)
		end do; end do; end do
!$omp end do nowait
!$omp end parallel
	end function exponentiation
	
	!>
	!! @brief
	!!
	function exponentiationFC( this, constant ) result( output )
		class(NFunction3D), intent(in) :: this
		real(8), intent(in) :: constant
		type(NFunction3D) :: output
		
		integer :: i, j, k
		
		output = this
! 		output.fArray = this.fArray**constant

!$omp parallel private(k)
!$omp do schedule(dynamic,1)
		do k=1,this.nPoints(3); do j=1,this.nPoints(2); do i=1,this.nPoints(1)
			output.fArray(i,j,k) = this.fArray(i,j,k)**constant
		end do; end do; end do
!$omp end do nowait
!$omp end parallel
	end function exponentiationFC	
	
	!>
	!! @brief Save the funtion in a file
	!!
	subroutine save( this, fileName, format )
		class(NFunction3D) :: this
		character(*), optional, intent(in) :: fileName
		integer, optional, intent(in) :: format
		
		integer :: effFormat
		
		character(100), allocatable :: tokens(:)
		character(100) :: extension
		
		effFormat = AUTO_FORMAT
		if( present(format) ) effFormat = format
		
		select case ( effFormat )
			case( AUTO_FORMAT )
				call FString_split( fileName, tokens, "." )
				extension = ""
				if( size( tokens ) > 1 ) extension = trim(tokens(size(tokens)))
				deallocate( tokens )
				
				if( trim(extension) == "n3df" ) then
					call this.saveN3DF( fileName )
				else if( trim(extension) == "cube" ) then
					call this.saveCUBE( fileName, CUBE_FORMAT )
				else if( trim(extension) == "rcube" ) then
					call this.saveCUBE( fileName, RCUBE_FORMAT )
				else if( trim(extension) == "icube" ) then
					call this.saveCUBE( fileName, ICUBE_FORMAT )
				else if( trim(extension) == "blks" ) then
					call this.saveBLKS( fileName )
				else
					call GOptions_error( &
						"Unknown format file (AUTO_FORMAT). FileName = "//trim(fileName), &
						"NFunction3D.save(extension="//trim(extension)//")" &
					)
				end if
			case( N3DF_FORMAT )
				call this.saveN3DF( fileName )
			case( CUBE_FORMAT )
				call this.saveCUBE( fileName, CUBE_FORMAT )
			case( RCUBE_FORMAT )
				call this.saveCUBE( fileName, RCUBE_FORMAT )
			case( ICUBE_FORMAT )
				call this.saveCUBE( fileName, ICUBE_FORMAT )
			case( BLKS_FORMAT )
				call this.saveBLKS( fileName )
			case default
				write(6,*) "### ERROR ### NFunction3D.save(). The format is not supported"
				stop
		end select
	end subroutine save
	
	!>
	!! @brief
	!!
	subroutine saveN3DF( this, fileName )
		class(NFunction3D) :: this
		character(*) :: fileName
		
		integer :: idType
		
		if( .not. this.xyzGrid.isEquallyspaced() ) then
			call GOptions_error( &
				"This subroutine is not available for functions wich are not equally spaced", &
				"NFunction3D.saveN3DF()" &
			)
		end if
		
		idType = __ID_TYPE__
		
		open( unit=1, file=trim(fileName), action='write', form="unformatted" )
		
		! 0 = REAL, 1 COMPLEX
		write(1) idType
		
		! origin of the grid
		write(1) this.xyzGrid.min(1), this.xyzGrid.min(2), this.xyzGrid.min(3)
		
		! Number of points for each coordinate
		write(1) this.xyzGrid.nPoints(1), this.xyzGrid.nPoints(2), this.xyzGrid.nPoints(3)
		
		! Increment for each coordinate
		write(1) this.xyzGrid.stepSize(1), this.xyzGrid.stepSize(2), this.xyzGrid.stepSize(3)
		
		!!!!!!!!!!!!!!!!!!!!!!!
		! Volumetric data
		write(1) this.fArray
		
		close(1)
	end subroutine saveN3DF
	
	!>
	!! @brief
	!!
	subroutine saveCUBE( this, fileName, format )
		class(NFunction3D), intent(in) :: this
		character(*), intent(in) :: fileName
		integer, optional, intent(in) :: format
		
		integer :: effFormat
		
		integer :: ix, iy, iz
		character(255) :: date
		
		if( .not. this.xyzGrid.isEquallyspaced() ) then
			call GOptions_error( &
				"This subroutine is not available for functions wich are not equally spaced", &
				"NFunction3D.saveCUBE()" &
			)
		end if
		
		call fdate(date)
		
		effFormat = CUBE_FORMAT
		if( present(format) ) effFormat = format
		
		open( unit=1, file=trim(fileName), status="unknown" )
		
		! The first and second line are simply comments
#if __ID_TYPE__ == 0
		write(1,*) "Real Numerical Function"
#elif __ID_TYPE__ == 1
		write(1,"(A)",advance="no") "Complex Numerical Function"
		select case( effFormat )
			case( CUBE_FORMAT )
				write(1,"(A)") "NORM"
			case( RCUBE_FORMAT )
				write(1,"(A)") "REAL"
			case( ICUBE_FORMAT )
				write(1,"(A)") "IMAG"
		end select
#endif
		write(1,*) trim(date)
		
		! The third line has the number of atoms
		! (in this case is the calcium atom) followed by
		! the position of the grid
		write(1, "(I4,F12.5,F12.5,F12.5)" ) 0, this.xyzGrid.min(1), this.xyzGrid.min(2), this.xyzGrid.min(3)
		
		! The next three lines have the following information for each coordinate
		! <number of points> <x_increment> <y_increment> <z_increment>
		write(1, "(I4,F12.5,F12.5,F12.5)" ) this.xyzGrid.nPoints(1), this.xyzGrid.stepSize(1),     0.0,     0.0
		write(1, "(I4,F12.5,F12.5,F12.5)" ) this.xyzGrid.nPoints(2),     0.0, this.xyzGrid.stepSize(2),     0.0
		write(1, "(I4,F12.5,F12.5,F12.5)" ) this.xyzGrid.nPoints(3),     0.0,     0.0, this.xyzGrid.stepSize(3)
		
		! The last section in the header is one for each atom consisting
		! of 5 numbers
		! <atomic number(integer)> <atomic number(real)> <x_coordinate> <y_coordinate> <z_coordinate>
! 		write(1, "(I4,F12.5,F12.5,F12.5,F12.5)" ) 20, 20.0, this.ximp, yimp, zimp
		
		!!!!!!!!!!!!!!!!!!!!!!!
		! Volumetric data
		do ix=1,this.xyzGrid.nPoints(1)
			do iy=1,this.xyzGrid.nPoints(2)
				
#if __ID_TYPE__ == 0
				write(1,"(6E13.5)") ( this.fArray(ix,iy,iz), iz=1,this.xyzGrid.nPoints(3) )
#elif __ID_TYPE__ == 1
				select case ( effFormat )
					case( CUBE_FORMAT )
						write(1,"(6E13.5)") ( abs(this.fArray(ix,iy,iz)), iz=1,this.xyzGrid.nPoints(3) )
					case( RCUBE_FORMAT )
						write(1,"(6E13.5)") ( real(this.fArray(ix,iy,iz)), iz=1,this.xyzGrid.nPoints(3) )
					case( ICUBE_FORMAT )
						write(1,"(6E13.5)") ( aimag(this.fArray(ix,iy,iz)), iz=1,this.xyzGrid.nPoints(3) )
					case default
						write(6,*) "### ERROR ### NFunction3D.saveCUBE(). The format is not supported"
						stop
				end select
#endif
			end do
		end do
		
		close(1)
	end subroutine saveCUBE
	
	!>
	!! @brief
	!!
	subroutine saveBLKS( this, fileName )
		class(NFunction3D), intent(in) :: this
		character(*), intent(in) :: fileName
		
		integer :: ix, iy, iz
		character(255) :: date
		
		call fdate(date)
		
		open( unit=1, file=trim(fileName), status="unknown" )
		
		! The first and second line are simply comments
#if __ID_TYPE__ == 0
		write(1,"(A)") "# Real Numerical Function"
#elif __ID_TYPE__ == 1
		write(1,"(A)") "# Complex Numerical Function"
#endif
		write(1,"(A)") "# XYZ"
		write(1,"(A)") "# "//trim(date)
		
		do ix=1,this.xyzGrid.nPoints(1)
			do iy=1,this.xyzGrid.nPoints(2)
				do iz=1,this.xyzGrid.nPoints(3)
				
#if __ID_TYPE__ == 0
					write(1,"(4E13.5)") this.xyzGrid.at(ix,iy,iz), this.fArray(ix,iy,iz)
#elif __ID_TYPE__ == 1
					write(1,"(5E13.5)") this.xyzGrid.at(ix,iy,iz), this.fArray(ix,iy,iz)
#endif
				end do
				
				write(1,*) ""
				write(1,*) ""
			end do
		end do
		
		close(1)
	end subroutine saveBLKS
	
	!>
	!! @brief
	!! @todo Solo está implementado el caso en que dir sea en dirección paralela a una coordenanda y origen 0.0,0.0,0.0
	!!
	subroutine saveProjection1D( this, fileName, origin, dir, resolution, append, beforeLine )
		class(NFunction3D), intent(in) :: this
		character(*), intent(in) :: fileName
		real(8) :: origin(3)
		integer, intent(in) :: dir(3)
		real(8), optional, intent(in) :: resolution
		logical, optional, intent(in) :: append
		character(*), optional, intent(in) :: beforeLine
		
		logical :: effAppend
		character(100) :: effBeforeLine
		integer :: invResolution
		
		real(8) :: minDir
		real(8) :: maxDir
		real(8) :: stepSizeDir
		real(8) :: valDir
		__TYPE_VALUE__ :: value
		
		real(8) :: ssum
		integer :: codeDir
		
		effAppend = .false.
		if( present(append) ) effAppend = append
		
		effBeforeLine = ""
		if( present(beforeLine) ) effBeforeLine = beforeLine
		
		invResolution = 1
		if( present(resolution) ) invResolution = ceiling( 1.0_8/resolution )
		
		if( effAppend ) then
			open( unit=1, file=trim(fileName), status="unknown", access="append" )
		else
			open( unit=1, file=trim(fileName), status="unknown" )
		end if
		
		if( .not. this.isEquallyspaced() ) then
			call GOptions_error( &
				"This subroutine is not available yet for functions wich are not equally spaced", &
				"NFunction3D.saveProjection1D()" &
			)
		end if
		
		codeDir = 3
		if( all(dir == [1,0,0]) ) then
			codeDir = 1
		else if( all(dir == [0,1,0]) ) then
			codeDir = 2
		else if( all(dir == [0,0,1]) ) then
			codeDir = 3
		else
			call GOptions_error( &
				"Direction "//FString_fromIntegerArray(dir)//" is not implemented yet. Try [1,0,0], [0,1,0] or [0,0,1]", &
				"NFunction3D.saveProjection1D()" &
			)
		end if
		
		minDir = this.xyzGrid.min(codeDir)
		maxDir = this.xyzGrid.max(codeDir)
		stepSizeDir = this.xyzGrid.stepSize(codeDir)*invResolution
		
		if( minDir > maxDir ) then
			call GOptions_error( &
				"minDir > maxDir ("//FString_fromReal(minDir)//" > "//FString_fromReal(maxDir)//")", &
				"NFunction3D.saveProjection1D()" &
			)
		end if
		
		valDir = minDir
		ssum = 0.0_8
		do while( valDir <= maxDir )
			value = this.evaluateXYZ( origin(1), origin(2), valDir )  !< Busca el punto más cercano, no interpola
			
#if __ID_TYPE__ == 1
			if( abs(value) > 1d-98 ) then
				write(1,"(A,3E13.5)") trim(effBeforeLine), valDir, real(value), aimag(value)
			else
				write(1,"(A,3E13.5)") trim(effBeforeLine), valDir, 0.0_8, 0.0_8
			end if
#elif __ID_TYPE__ == 0
			if( abs(value) > 1d-98 ) then
				write(1,"(A,2E13.5)") trim(effBeforeLine), valDir, value
			else
				write(1,"(A,2E13.5)") trim(effBeforeLine), valDir, 0.0_8
			end if
#endif
			ssum = ssum  + abs(value)**2
			
			valDir = valDir + stepSizeDir
		end do
		
		write(1,*) "# norm = ", sqrt(1.0_8/(stepSizeDir*ssum))
		write(1,*) ""
		write(1,*) ""
		
		close(1)
	end subroutine saveProjection1D
	
	!>
	!! @brief
	!!
	subroutine saveProjection2D( this, fileName, n, p0, nx, ny, append )
		class(NFunction3D), intent(in) :: this
		character(*), intent(in) :: fileName
		real(8), optional, intent(in) :: n(3)
		real(8), optional, intent(in) :: p0(3)
		integer, optional, intent(in) :: nx, ny
		logical, optional, intent(in) :: append
		
		real(8) :: effN(3)
		real(8) :: effP0(3)
		integer :: effNx, effNy
		logical :: effAppend
		
		real(8) :: x, y, z
		
		real(8) :: xp, yp
		real(8) :: xpMin, xpMax, xpStepSize
		real(8) :: ypMin, ypMax, ypStepSize
		character(255) :: date
		
		effAppend = .false.
		if( present(append) ) effAppend = append
		
		effN = [ 1.0_8, 0.01_8, 0.01_8 ]  ! plane X=cte
		if( present(n) ) effN = n
		
		effNx = 100
		if( present(nx) ) effNx = nx
		
		effNy = 100
		if( present(ny) ) effNy = ny
		
		effP0 = [ 0.0_8, 0.0_8, 0.0_8 ]  ! plane que pasa por X=0.0
		if( present(p0) ) effP0 = p0
		
		call fdate(date)
		
		if( effAppend ) then
			open( unit=1, file=trim(fileName), status="unknown", access="append" )
		else
			open( unit=1, file=trim(fileName), status="unknown" )
		end if
		
#if __ID_TYPE__ == 0
		write(1,"(A)") "# Real Numerical Function"
#elif __ID_TYPE__ == 1
		write(1,"(A)") "# Complex Numerical Function"
#endif
		write(1,"(A)") "# "//trim(date)
		
		!----------------------------------------
		! xp^2 = x^2 + y^2
		! yp = z
		!----------------------------------------
		
		xpMin = this.xyzGrid.min(1)/cos( Math_PI/4.0_8 )
		xpMax = this.xyzGrid.max(1)/cos( Math_PI/4.0_8 )
! 		xpStepSize = sin( Math_PI/4.0_8 )*( this.xyzGrid.stepSize(1)**2 + this.xyzGrid.stepSize(2)**2 )
		xpStepSize = (xpMax-xpMin)/real(effNx+1,8)
		
		ypMin = this.xyzGrid.min(3)
		ypMax = this.xyzGrid.max(3)
! 		ypStepSize = this.xyzGrid.stepSize(3)
		ypStepSize = (ypMax-ypMin)/real(effNy+1,8)
		
		xp = xpMin
		do while( xp <= xpMax )
				
			yp = ypMin
			do while( yp <= ypMax )
				
				x = cos( Math_PI/4.0_8 )*xp
				y = sin( Math_PI/4.0_8 )*xp
				z = yp
				
! 				z = effP0(3)-effN(1)*(xp-effP0(1))/effN(3)-effN(2)*(yp-effP0(2))/effN(3)
#if __ID_TYPE__ == 1
				write(1,"(4E13.5)") xp, yp, real(this.evaluateXYZ(x,y,z)), aimag(this.evaluateXYZ(x,y,z))
#elif __ID_TYPE__ == 0
				write(1,"(3E13.5)") xp, yp, this.evaluateXYZ(x,y,z)
#endif
				
				yp = yp + ypStepSize
			end do
			
			write(1,*) ""
			
			xp = xp + xpStepSize
		end do
		
		write(1,*) ""
		write(1,*) ""

! 		!----------------------------------------
! 		! xp = x
! 		! yp = z
! 		!----------------------------------------
! 		
! 		xpMin = this.xyzGrid.min(1)
! 		xpMax = this.xyzGrid.max(1)
! 		xpStepSize = this.xyzGrid.stepSize(1)
! 		
! 		ypMin = this.xyzGrid.min(3)
! 		ypMax = this.xyzGrid.max(3)
! 		ypStepSize = this.xyzGrid.stepSize(3)
! 		
! 		xp = xpMin
! 		do while( xp <= xpMax )
! 				
! 			yp = ypMin
! 			do while( yp <= ypMax )
! 				
! 				x = xp
! 				y = 3.5975_8/2.0_8
! 				z = yp
! 				
! ! 				z = effP0(3)-effN(1)*(xp-effP0(1))/effN(3)-effN(2)*(yp-effP0(2))/effN(3)
! #if __ID_TYPE__ == 1
! 				write(1,"(4E13.5)") xp, yp, real(this.evaluateXYZ(x,y,z)), aimag(this.evaluateXYZ(x,y,z))
! #elif __ID_TYPE__ == 0
! 				write(1,"(3E13.5)") xp, yp, this.evaluateXYZ(x,y,z)
! #endif
! 				
! 				yp = yp + ypStepSize
! 			end do
! 			
! 			write(1,*) ""
! 			
! 			xp = xp + xpStepSize
! 		end do
! 		
! 		write(1,*) ""
! 		write(1,*) ""
		
		close(1)
	end subroutine saveProjection2D
	
	!>
	!! @brief
	!!
	subroutine loadCUBE( this, fileName, format, debug )
		class(NFunction3D) :: this
		character(*) :: fileName
		integer, optional, intent(in) :: format
		logical, optional, intent(in) :: debug
		
		integer :: effFormat
		logical :: effDebug
		
		character(100) :: sBuffer
		integer :: nAtoms
		real(8) :: rBuffer
		real(8) :: xMin, yMin, zMin
		real(8) :: xMax, yMax, zMax
		real(8) :: hx, hy, hz
		integer :: nx, ny, nz
		integer :: i, ix, iy, iz
		__TYPE_VALUE__, allocatable :: fArray(:,:,:)
		real(8), allocatable :: cubeDataLine(:)
		
		type(Grid3D) :: xyzGrid
		
		effFormat = CUBE_FORMAT
		if( present(format) ) effFormat = format
		
		effDebug = .false.
		if( present(debug) ) effDebug = debug
		
		open( unit=1, file=trim(fileName), status='old' )
		
		read(1,*) sBuffer ! title
		read(1,*) sBuffer ! comments
		read(1,*) nAtoms, xMin, yMin, zMin
		read(1,*) nx,      hx, rBuffer, rBuffer
		read(1,*) ny, rBuffer,      hy, rBuffer
		read(1,*) nz, rBuffer, rBuffer,      hz
		
		if( effDebug ) then
			write(*,*) "==================================================="
			write(*,*) " Loading cube "//trim(fileName)
			write(*,*) "==================================================="
			select case ( effFormat )
				case( CUBE_FORMAT )
					write(*,*) " format = ", "CUBE_FORMAT"
				case( RCUBE_FORMAT )
					write(*,*) " format = ", "RCUBE_FORMAT"
				case( ICUBE_FORMAT )
					write(*,*) " format = ", "ICUBE_FORMAT"
				case default
					write(6,*) "### ERROR ### NFunction3D.loadCUBE(). The format is not supported"
					stop
			end select
			write(*,"(A,I10)") "  nAtoms = ", nAtoms
			write(*,"(A,3F10.5,A)") "     min = ( ", xMin, yMin, zMin, " )"
			write(*,"(A,3I10,A)") "       n = ( ", nx, ny, nz, " )"
			write(*,"(A,3F10.5,A)") "       h = ( ", hx, hy, hz, " )"
		end if

		xMax = xMin + (nx-1)*hx
		yMax = yMin + (ny-1)*hy
		zMax = zMin + (nz-1)*hz
		
		if( effDebug ) then
			write(*,"(A,3F10.5,A)") "     max = ( ", xMax, yMax, zMax, " )"
		end if
		
		do i=1,nAtoms
			read(1,"(A)") sBuffer
		end do
		
		allocate( fArray( nx, ny, nz ) )
		allocate( cubeDataLine(nz) )
		
		do ix=1,nx
			do iy=1,ny
				read(1,"(6E13.5)") ( cubeDataLine(iz), iz=1,nz )
				
#if __ID_TYPE__ == 0
				fArray(ix,iy,:) = cubeDataLine(:)
#elif __ID_TYPE__ == 1
				select case ( effFormat )
					case( CUBE_FORMAT )
						fArray(ix,iy,:) = cmplx( cubeDataLine(:), 0.0_8 )
					case( RCUBE_FORMAT )
						fArray(ix,iy,:) = cmplx( cubeDataLine(:), 0.0_8 )
					case( ICUBE_FORMAT )
						fArray(ix,iy,:) = cmplx( 0.0_8, cubeDataLine(:) )
					case default
						write(6,*) "### ERROR ### NFunction3D.loadCUBE(). The format is not supported"
						stop
				end select
#endif
			end do
		end do
		
		call xyzGrid.init( min=[xMin,yMin,zMin], max=[xMax,yMax,zMax], size=[nx,ny,nz] )
		call this.fromGrid3DArray( xyzGrid, fArray )
		
		close(1)
		
		deallocate( fArray )
		deallocate( cubeDataLine )
	end subroutine loadCUBE
	
	!>
	!! @brief
	!!
	subroutine loadBLKS( this, fileName, debug )
		class(NFunction3D) :: this
		character(*) :: fileName
		logical, optional, intent(in) :: debug
		
		logical :: effDebug
		
		effDebug = .false.
		if( present(debug) ) effDebug = debug
		
		call GOptions_error( &
			"This subroutine is not implemented yet", &
			"NFunction3D.loadBLKS()" &
		)
		
		open( unit=1, file=trim(fileName), status='old' )
		
		
		
		close(1)
	end subroutine loadBLKS
	
	!>
	!! @brief Return 1 if fileName contains real numbers,
	!!        0 if fileName contains real numbers and
	!!        -1 elsewhere
	!!
	function checkTypeN3DF( this, fileName ) result( output )
		class(NFunction3D) :: this
		character(*) :: fileName
		integer :: idType
		integer :: output
		
		open( unit=1, file=trim(fileName), action='read', form="unformatted" )
		
		! 0 = REAL, 1 COMPLEX
		read(1) idType
		
		close(1)
		
		if( idType /= 0 .and. idType /= 1 ) then
			output = -1
		else
			output = idType
		end if
	end function checkTypeN3DF
	
	!>
	!! @brief
	!!
	subroutine loadN3DF( this, fileName )
		class(NFunction3D) :: this
		character(*) :: fileName
		
		real(8) :: xMin, yMin, zMin
		real(8) :: xMax, yMax, zMax
		real(8) :: hx, hy, hz
		integer :: nx, ny, nz
		integer :: idType
		__TYPE_VALUE__, allocatable :: fArray(:,:,:)
		
		type(Grid3D) :: xyzGrid
		
		open( unit=1, file=trim(fileName), action='read', form="unformatted" )
		
		! 0 = REAL, 1 COMPLEX
		read(1) idType
		
		if( idType /= __ID_TYPE__ ) then
			write(*,*) "### ERROR ### NFunction3D.loadN3DF(): Inconsistent type in file"
			stop
		end if
		
		! origin of the grid
		read(1) xMin, yMin, zMin
		
		! Number of points for each coordinate
		read(1) nx, ny, nz
		
		! Increment for each coordinate
		read(1) hx, hy, hz
		
		xMax = xMin + (nx-1)*hx
		yMax = yMin + (ny-1)*hy
		zMax = zMin + (nz-1)*hz
		
		allocate( fArray(nx,ny,nz) )
		
		!!!!!!!!!!!!!!!!!!!!!!!
		! Volumetric data
		read(1) fArray
		
		call xyzGrid.init( min=[xMin,yMin,zMin], max=[xMax,yMax,zMax], size=[nx,ny,nz] )
		call this.fromGrid3DArray( xyzGrid, fArray )
		
		deallocate( fArray )
		
		close(1)
	end subroutine loadN3DF

	!>
	!! @brief 
	!!
	subroutine normalize( this, constant )
		class(NFunction3D) :: this
		real(8), optional, intent(out) :: constant
		
		integer :: i, j, k
		real(8) :: nConstant
		
		nConstant = 1.0_8/this.norm()
		
!$omp parallel private(k)
!$omp do schedule(dynamic,1)
		do k=1,this.xyzGrid.nPoints(3)
			do j=1,this.xyzGrid.nPoints(2)
				do i=1,this.xyzGrid.nPoints(1)
					this.fArray(i,j,k) = nConstant*this.fArray(i,j,k)
				end do
			end do
		end do
!$omp end do nowait
!$omp end parallel
		
		if( present(constant) ) then
			constant = nConstant
		end if
	end subroutine normalize
	
	!>
	!! @brief 
	!!
	pure function norm( this ) result( output )
		class(NFunction3D), intent(in) :: this
		real(8) :: output
		
#if __ID_TYPE__ == 1
		output = sqrt( sum( conjg(this.fArray)*this.fArray )*this.xyzGrid.dV() )
#else
		output = sqrt( sum( this.fArray*this.fArray )*this.xyzGrid.dV() )
#endif

! ! !$omp parallel private(k)
! ! !$omp do schedule(dynamic,1)
! ! 		output = 0.0_8
! ! 		do k=1,this.nPoints(3); do j=1,this.nPoints(2); do i=1,this.nPoints(1)
! ! #if __ID_TYPE__ == 1
! ! 			output = sqrt( sum( conjg(this.fArray)*this.fArray )*this.xyzGrid.dV() )
! ! #else
! ! 			output = sqrt( sum( this.fArray*this.fArray )*this.xyzGrid.dV() )
! ! #endif
! ! 			output.fArray(i,j,k) = this.fArray(i,j,k)**other.fArray(i,j,k)
! ! 		end do; end do; end do
! ! !$omp end do nowait
! ! !$omp end parallel
	end function norm
	
	!>
	!! @brief 
	!!
	function expectationValueFromNFunction( this, oper, checkBox ) result( output )
		class(NFunction3D), intent(in) :: this
		class(NFunction3D), intent(in) :: oper
		logical, optional, intent(in) :: checkBox
		__TYPE_VALUE__ :: output
		
		logical :: effCheckBox
		
		effCheckBox = .true.
		if( present(checkBox) ) effCheckBox = checkBox
		
		if( effCheckBox ) then
			if( .not. this.checkBox( oper ) ) then
				call GOptions_error( "Inconsistent boxes", "NFunction3D.expectationValueFromNFunction()" )
			end if
		end if
		
#if __ID_TYPE__ == 1
		output = sum( conjg(this.fArray)*oper.fArray*this.fArray )*this.xyzGrid.dV()
#else
		output = sum( this.fArray*oper.fArray*this.fArray )*this.xyzGrid.dV()
#endif
	end function expectationValueFromNFunction
	
	!>
	!! @brief 
	!!
	function expectationValueFromRArray( this, oper, checkBox, factor ) result( output )
		class(NFunction3D), intent(in) :: this
		real(8), intent(in) :: oper(:,:,:)
		logical, optional, intent(in) :: checkBox
		real(8), optional, intent(in) :: factor
		__TYPE_VALUE__ :: output
		
		logical :: effCheckBox
		real(8) :: effFactor
		
		effCheckBox = .true.
		if( present(checkBox) ) effCheckBox = checkBox
		
		effFactor = 1.0_8
		if( present(factor) ) effFactor = factor
		
		if( effCheckBox ) then
			if( this.nPoints(1) /= size(oper,dim=1) &
				  .or. this.nPoints(2) /= size(oper,dim=2) &
				  .or. this.nPoints(3) /= size(oper,dim=3) ) then
				call GOptions_error( &
					"Inconsistent boxes", &
					"NFunction3D.expectationValueFromRArray()", &
					"("//trim(FString_fromInteger(this.nPoints(1)))//"," &
					   //trim(FString_fromInteger(this.nPoints(2)))//"," &
					   //trim(FString_fromInteger(this.nPoints(3)))//") /= (" &
					   //trim(FString_fromInteger(size(oper,dim=1)))//"," &
					   //trim(FString_fromInteger(size(oper,dim=2)))//"," &
					   //trim(FString_fromInteger(size(oper,dim=3)))//")" &
					)
			end if
		end if
		
#if __ID_TYPE__ == 1
		output = effFactor*sum( conjg(this.fArray)*oper*this.fArray )*this.xyzGrid.dV()
#else
		output = effFactor*sum( this.fArray*oper*this.fArray )*this.xyzGrid.dV()
#endif
	end function expectationValueFromRArray
	
	!>
	!! @brief 
	!!
	function expectationValueFromCArray( this, oper, checkBox ) result( output )
		class(NFunction3D), intent(in) :: this
		complex(8), intent(in) :: oper(:,:,:)
		logical, optional, intent(in) :: checkBox
		__TYPE_VALUE__ :: output
		
		logical :: effCheckBox
		
		integer :: i, j, k
		integer :: nx, ny, nz
		
		nx = this.xyzGrid.nPoints(1)
		ny = this.xyzGrid.nPoints(2)
		nz = this.xyzGrid.nPoints(3)
		
		effCheckBox = .true.
		if( present(checkBox) ) effCheckBox = checkBox
		
		if( effCheckBox ) then
			if( this.xyzGrid.nPoints(1) /= size(oper,dim=1) &
				  .or. this.xyzGrid.nPoints(2) /= size(oper,dim=2) &
				  .or. this.xyzGrid.nPoints(3) /= size(oper,dim=3) ) then
				call GOptions_error( &
					"Inconsistent boxes", &
					"NFunction3D.expectationValueFromCArray()", &
					"("//trim(FString_fromInteger(this.xyzGrid.nPoints(1)))//"," &
					   //trim(FString_fromInteger(this.xyzGrid.nPoints(2)))//"," &
					   //trim(FString_fromInteger(this.xyzGrid.nPoints(3)))//") /= (" &
					   //trim(FString_fromInteger(size(oper,dim=1)))//"," &
					   //trim(FString_fromInteger(size(oper,dim=2)))//"," &
					   //trim(FString_fromInteger(size(oper,dim=3)))//")" &
					)
			end if
		end if
		
#if __ID_TYPE__ == 1
! 		output = sum( conjg(this.fArray)*oper*this.fArray )*this.xyzGrid.dV()
		output = 0.0_8
		do k=1,nz; do j=1,ny; do i=1,nx
			output = output + conjg(this.fArray(i,j,k))*oper(i,j,k)*this.fArray(i,j,k)
		end do; end do; end do
		output = output*this.xyzGrid.dV()
#else
		output = sum( this.fArray*oper*this.fArray )*this.xyzGrid.dV()
#endif
	end function expectationValueFromCArray
	
	!>
	!! @brief
	!!
	subroutine set( this, i, j, k, value )
		class(NFunction3D) :: this
		integer, intent(in) :: i, j, k
		__TYPE_VALUE__, intent(in) :: value
		
		this.fArray( i, j, k ) = value
	end subroutine set
	
	!>
	!! @brief
	!!
	pure function at( this, i, j, k ) result( output )
		class(NFunction3D), intent(in) :: this
		integer, intent(in) :: i, j, k
		__TYPE_VALUE__ :: output
		
		output = this.fArray( i, j, k )
	end function at
	
	!>
	!! @brief
	!!
	pure function x( this, pos ) result( output )
		class(NFunction3D), intent(in) :: this
		integer, intent(in) :: pos
		__TYPE_VALUE__ :: output
		
		output = this.xyzGrid.component(1).at( pos )
	end function x
	
	!>
	!! @brief
	!!
	pure function y( this, pos ) result( output )
		class(NFunction3D), intent(in) :: this
		integer, intent(in) :: pos
		__TYPE_VALUE__ :: output
		
		output = this.xyzGrid.component(2).at( pos )
	end function y
	
	!>
	!! @brief
	!!
	pure function z( this, pos ) result( output )
		class(NFunction3D), intent(in) :: this
		integer, intent(in) :: pos
		__TYPE_VALUE__ :: output
		
		output = this.xyzGrid.component(3).at( pos )
	end function z
	
	!>
	!! @brief
	!!
	pure function minInCoord( this, pos ) result( output )
		class(NFunction3D), intent(in) :: this
		integer, intent(in) :: pos
		real(8) :: output
		
		output = this.xyzGrid.min( pos )
	end function minInCoord
	
	!>
	!! @brief
	!!
	pure function minVec( this ) result( output )
		class(NFunction3D), intent(in) :: this
		real(8) :: output(3)
		
		output = this.xyzGrid.min()
	end function minVec
	
	!>
	!! @brief
	!!
	pure function maxInCoord( this, pos ) result( output )
		class(NFunction3D), intent(in) :: this
		integer, intent(in) :: pos
		real(8) :: output
		
		output = this.xyzGrid.max( pos )
	end function maxInCoord
	
	!>
	!! @brief
	!!
	pure function maxVec( this ) result( output )
		class(NFunction3D), intent(in) :: this
		real(8) :: output(3)
		
		output = this.xyzGrid.max()
	end function maxVec
	
	!>
	!! @brief
	!!
	pure function stepSizeInCoord( this, pos ) result( output )
		class(NFunction3D), intent(in) :: this
		integer, intent(in) :: pos
		real(8) :: output
		
		output = this.xyzGrid.stepSize( pos )
	end function stepSizeInCoord
	
	!>
	!! @brief
	!!
	pure function stepSizeVec( this ) result( output )
		class(NFunction3D), intent(in) :: this
		real(8) :: output(3)
		
		output = this.xyzGrid.stepSize()
	end function stepSizeVec
	
	!>
	!! @brief
	!!
	function isEquallyspaced( this ) result( output )
		class(NFunction3D), intent(in) :: this
		logical :: output
		
		output = this.xyzGrid.isEquallyspaced()
	end function isEquallyspaced
	
	!>
	!! @brief
	!!
	subroutine checkEquallyspaced( this )
		class(NFunction3D) :: this
		
		call this.xyzGrid.checkEquallyspaced()
	end subroutine checkEquallyspaced
	
	!>
	!! @brief Returns the number of points of the direction i-th (X,Y,Z)
	!!
	function ssize( this, i ) result( output )
		class(NFunction3D), intent(in) :: this
		integer, optional, intent(in) :: i
		integer :: output
		
		if( present(i) ) then
			output = this.xyzGrid.nPoints(i)
		else
			output = this.xyzGrid.nPoints(1)*this.xyzGrid.nPoints(2)*this.xyzGrid.nPoints(3)
		end if
	end function ssize
	
	!>
	!! Code here is based on:
	!! https://raw.githubusercontent.com/deepzot/likely/master/likely/TriCubicInterpolator.cc
	!! https://svn.blender.org/svnroot/bf-blender/branches/volume25/source/blender/blenlib/intern/voxel.c
	!! 
	function interpolate( this, x, y, z ) result( output )
		class(NFunction3D), intent(in) :: this
		real(8) :: x, y, z
		__TYPE_VALUE__ :: output
		
		real(8) :: dx, dy, dz
		integer :: xi, yi, zi
		
		__TYPE_VALUE__ :: derivatives(64)
		__TYPE_VALUE__ :: coeff(64)
		integer :: i, j, k, ijkn
		real(8) :: dzpow
		real(8) :: dypow
		
		real(8) :: rOutput, iOutput
		
		! Map x,y,z to a point dx,dy,dz in the cube [1,n1] x [1,n2] x [1,n3]
		xi = floor( 1.0000001*(x-this.min(1))/this.stepSize(1)+1.0 )
		yi = floor( 1.0000001*(y-this.min(2))/this.stepSize(2)+1.0 )
		zi = floor( 1.0000001*(z-this.min(3))/this.stepSize(3)+1.0 )
		
		dx = mod( x - this.min(1) + 1.0000001*this.stepSize(1), this.stepSize(1) )/this.stepSize(1)
		dy = mod( y - this.min(2) + 1.0000001*this.stepSize(2), this.stepSize(2) )/this.stepSize(2)
		dz = mod( z - this.min(3) + 1.0000001*this.stepSize(3), this.stepSize(3) )/this.stepSize(3)

#define p this.fArray
		! Extract the local vocal values and calculate partial derivatives.
		derivatives = [ &
			! values of f(x,y,z) at each corner.
			p(xi  ,yi  ,zi  ), &
			p(xi+1,yi  ,zi  ), &
			p(xi  ,yi+1,zi  ), &
			p(xi+1,yi+1,zi  ), &
			p(xi  ,yi  ,zi+1), &
			p(xi+1,yi  ,zi+1), &
			p(xi  ,yi+1,zi+1), &
			p(xi+1,yi+1,zi+1), &
			
			! values of df/dx at each corner.
			0.5*(p(xi+1,yi  ,zi  )-p(xi-1,yi  ,zi  )), &
			0.5*(p(xi+2,yi  ,zi  )-p(xi  ,yi  ,zi  )), &
			0.5*(p(xi+1,yi+1,zi  )-p(xi-1,yi+1,zi  )), &
			0.5*(p(xi+2,yi+1,zi  )-p(xi  ,yi+1,zi  )), &
			0.5*(p(xi+1,yi  ,zi+1)-p(xi-1,yi  ,zi+1)), &
			0.5*(p(xi+2,yi  ,zi+1)-p(xi  ,yi  ,zi+1)), &
			0.5*(p(xi+1,yi+1,zi+1)-p(xi-1,yi+1,zi+1)), &
			0.5*(p(xi+2,yi+1,zi+1)-p(xi  ,yi+1,zi+1)), &
				
			! values of df/dy at each corner.
			0.5*(p(xi  ,yi+1,zi  )-p(xi  ,yi-1,zi  )), &
			0.5*(p(xi+1,yi+1,zi  )-p(xi+1,yi-1,zi  )), &
			0.5*(p(xi  ,yi+2,zi  )-p(xi  ,yi  ,zi  )), &
			0.5*(p(xi+1,yi+2,zi  )-p(xi+1,yi  ,zi  )), &
			0.5*(p(xi  ,yi+1,zi+1)-p(xi  ,yi-1,zi+1)), &
			0.5*(p(xi+1,yi+1,zi+1)-p(xi+1,yi-1,zi+1)), &
			0.5*(p(xi  ,yi+2,zi+1)-p(xi  ,yi  ,zi+1)), &
			0.5*(p(xi+1,yi+2,zi+1)-p(xi+1,yi  ,zi+1)), &
				
			! values of df/dz at each corner.
			0.5*(p(xi  ,yi  ,zi+1)-p(xi  ,yi  ,zi-1)), &
			0.5*(p(xi+1,yi  ,zi+1)-p(xi+1,yi  ,zi-1)), &
			0.5*(p(xi  ,yi+1,zi+1)-p(xi  ,yi+1,zi-1)), &
			0.5*(p(xi+1,yi+1,zi+1)-p(xi+1,yi+1,zi-1)), &
			0.5*(p(xi  ,yi  ,zi+2)-p(xi  ,yi  ,zi  )), &
			0.5*(p(xi+1,yi  ,zi+2)-p(xi+1,yi  ,zi  )), &
			0.5*(p(xi  ,yi+1,zi+2)-p(xi  ,yi+1,zi  )), &
			0.5*(p(xi+1,yi+1,zi+2)-p(xi+1,yi+1,zi  )), &
				
			! values of d2f/dxdy at each corner.
			0.25*(p(xi+1,yi+1,zi  )-p(xi-1,yi+1,zi  )-p(xi+1,yi-1,zi  )+p(xi-1,yi-1,zi  )), &
			0.25*(p(xi+2,yi+1,zi  )-p(xi  ,yi+1,zi  )-p(xi+2,yi-1,zi  )+p(xi  ,yi-1,zi  )), &
			0.25*(p(xi+1,yi+2,zi  )-p(xi-1,yi+2,zi  )-p(xi+1,yi  ,zi  )+p(xi-1,yi  ,zi  )), &
			0.25*(p(xi+2,yi+2,zi  )-p(xi  ,yi+2,zi  )-p(xi+2,yi  ,zi  )+p(xi  ,yi  ,zi  )), &
			0.25*(p(xi+1,yi+1,zi+1)-p(xi-1,yi+1,zi+1)-p(xi+1,yi-1,zi+1)+p(xi-1,yi-1,zi+1)), &
			0.25*(p(xi+2,yi+1,zi+1)-p(xi  ,yi+1,zi+1)-p(xi+2,yi-1,zi+1)+p(xi  ,yi-1,zi+1)), &
			0.25*(p(xi+1,yi+2,zi+1)-p(xi-1,yi+2,zi+1)-p(xi+1,yi  ,zi+1)+p(xi-1,yi  ,zi+1)), &
			0.25*(p(xi+2,yi+2,zi+1)-p(xi  ,yi+2,zi+1)-p(xi+2,yi  ,zi+1)+p(xi  ,yi  ,zi+1)), &
				
			! values of d2f/dxdz at each corner.
			0.25*(p(xi+1,yi  ,zi+1)-p(xi-1,yi  ,zi+1)-p(xi+1,yi  ,zi-1)+p(xi-1,yi  ,zi-1)), &
			0.25*(p(xi+2,yi  ,zi+1)-p(xi  ,yi  ,zi+1)-p(xi+2,yi  ,zi-1)+p(xi  ,yi  ,zi-1)), &
			0.25*(p(xi+1,yi+1,zi+1)-p(xi-1,yi+1,zi+1)-p(xi+1,yi+1,zi-1)+p(xi-1,yi+1,zi-1)), &
			0.25*(p(xi+2,yi+1,zi+1)-p(xi  ,yi+1,zi+1)-p(xi+2,yi+1,zi-1)+p(xi  ,yi+1,zi-1)), &
			0.25*(p(xi+1,yi  ,zi+2)-p(xi-1,yi  ,zi+2)-p(xi+1,yi  ,zi  )+p(xi-1,yi  ,zi  )), &
			0.25*(p(xi+2,yi  ,zi+2)-p(xi  ,yi  ,zi+2)-p(xi+2,yi  ,zi  )+p(xi  ,yi  ,zi  )), &
			0.25*(p(xi+1,yi+1,zi+2)-p(xi-1,yi+1,zi+2)-p(xi+1,yi+1,zi  )+p(xi-1,yi+1,zi  )), &
			0.25*(p(xi+2,yi+1,zi+2)-p(xi,yi+1  ,zi+2)-p(xi+2,yi+1,zi  )+p(xi  ,yi+1,zi  )), &
				
			! values of d2f/dydz at each corner.
			0.25*(p(xi  ,yi+1,zi+1)-p(xi  ,yi-1,zi+1)-p(xi  ,yi+1,zi-1)+p(xi  ,yi-1,zi-1)), &
			0.25*(p(xi+1,yi+1,zi+1)-p(xi+1,yi-1,zi+1)-p(xi+1,yi+1,zi-1)+p(xi+1,yi-1,zi-1)), &
			0.25*(p(xi  ,yi+2,zi+1)-p(xi  ,yi  ,zi+1)-p(xi  ,yi+2,zi-1)+p(xi  ,yi  ,zi-1)), &
			0.25*(p(xi+1,yi+2,zi+1)-p(xi+1,yi  ,zi+1)-p(xi+1,yi+2,zi-1)+p(xi+1,yi  ,zi-1)), &
			0.25*(p(xi  ,yi+1,zi+2)-p(xi  ,yi-1,zi+2)-p(xi  ,yi+1,zi  )+p(xi  ,yi-1,zi  )), &
			0.25*(p(xi+1,yi+1,zi+2)-p(xi+1,yi-1,zi+2)-p(xi+1,yi+1,zi  )+p(xi+1,yi-1,zi  )), &
			0.25*(p(xi  ,yi+2,zi+2)-p(xi  ,yi  ,zi+2)-p(xi  ,yi+2,zi  )+p(xi  ,yi  ,zi  )), &
			0.25*(p(xi+1,yi+2,zi+2)-p(xi+1,yi  ,zi+2)-p(xi+1,yi+2,zi  )+p(xi+1,yi  ,zi  )), &
				
			! values of d3f/dxdydz at each corner.
			0.125*(p(xi+1,yi+1,zi+1)-p(xi-1,yi+1,zi+1)-p(xi+1,yi-1,zi+1)+p(xi-1,yi-1,zi+1)-p(xi+1,yi+1,zi-1)+p(xi-1,yi+1,zi-1)+p(xi+1,yi-1,zi-1)-p(xi-1,yi-1,zi-1)), &
			0.125*(p(xi+2,yi+1,zi+1)-p(xi  ,yi+1,zi+1)-p(xi+2,yi-1,zi+1)+p(xi  ,yi-1,zi+1)-p(xi+2,yi+1,zi-1)+p(xi  ,yi+1,zi-1)+p(xi+2,yi-1,zi-1)-p(xi  ,yi-1,zi-1)), &
			0.125*(p(xi+1,yi+2,zi+1)-p(xi-1,yi+2,zi+1)-p(xi+1,yi  ,zi+1)+p(xi-1,yi  ,zi+1)-p(xi+1,yi+2,zi-1)+p(xi-1,yi+2,zi-1)+p(xi+1,yi  ,zi-1)-p(xi-1,yi  ,zi-1)), &
			0.125*(p(xi+2,yi+2,zi+1)-p(xi  ,yi+2,zi+1)-p(xi+2,yi  ,zi+1)+p(xi  ,yi  ,zi+1)-p(xi+2,yi+2,zi-1)+p(xi  ,yi+2,zi-1)+p(xi+2,yi  ,zi-1)-p(xi  ,yi  ,zi-1)), &
			0.125*(p(xi+1,yi+1,zi+2)-p(xi-1,yi+1,zi+2)-p(xi+1,yi-1,zi+2)+p(xi-1,yi-1,zi+2)-p(xi+1,yi+1,zi  )+p(xi-1,yi+1,zi  )+p(xi+1,yi-1,zi  )-p(xi-1,yi-1,zi  )), &
			0.125*(p(xi+2,yi+1,zi+2)-p(xi  ,yi+1,zi+2)-p(xi+2,yi-1,zi+2)+p(xi  ,yi-1,zi+2)-p(xi+2,yi+1,zi  )+p(xi  ,yi+1,zi  )+p(xi+2,yi-1,zi  )-p(xi  ,yi-1,zi  )), &
			0.125*(p(xi+1,yi+2,zi+2)-p(xi-1,yi+2,zi+2)-p(xi+1,yi  ,zi+2)+p(xi-1,yi  ,zi+2)-p(xi+1,yi+2,zi  )+p(xi-1,yi+2,zi  )+p(xi+1,yi  ,zi  )-p(xi-1,yi  ,zi  )), &
			0.125*(p(xi+2,yi+2,zi+2)-p(xi  ,yi+2,zi+2)-p(xi+2,yi  ,zi+2)+p(xi  ,yi  ,zi+2)-p(xi+2,yi+2,zi  )+p(xi  ,yi+2,zi  )+p(xi+2,yi  ,zi  )-p(xi  ,yi  ,zi  )) &
		]
#undef p
			
		! Convert voxel values and partial derivatives to interpolation coefficients.
		do i=1,64
			coeff(i) = 0.0_8
			do j=1,64
				coeff(i) = coeff(i) + voxelCoeff(j,i)*derivatives(j)
			end do
		end do
		
		! Evaluate the interpolation within this grid voxel.
		ijkn = 1
		dzpow = 1.0_8
		rOutput = 0.0_8
		do k=1,4
			dypow = 1.0_8
			do j=1,4
				rOutput = rOutput &
						+ dypow*dzpow*( real(coeff(ijkn)) &
						+ dx*( real(coeff(ijkn+1)) &
						+ dx*( real(coeff(ijkn+2)) + dx*real(coeff(ijkn+3)) ) ) )
				ijkn = ijkn + 4
				dypow = dypow*dy
			end do
			dzpow = dzpow*dz
		end do
		
#if __ID_TYPE__ == 0
		output = rOutput
		
#elif __ID_TYPE__ == 1
		ijkn = 1
		dzpow = 1.0_8
		iOutput = 0.0_8
		do k=1,4
			dypow = 1.0_8
			do j=1,4
				iOutput = iOutput &
						+ dypow*dzpow*( aimag(coeff(ijkn)) &
						+ dx*( aimag(coeff(ijkn+1)) &
						+ dx*( aimag(coeff(ijkn+2)) + dx*aimag(coeff(ijkn+3)) ) ) )
				ijkn = ijkn + 4
				dypow = dypow*dy
			end do
			dzpow = dzpow*dz
		end do
		
		output = cmplx( rOutput, iOutput )
#else
		call GOptions_error( "Unknown __ID_TYPE__", "NFunction3D.interpolate()" )
#endif
		
	end function interpolate
	
	!>
	!! @brief
	!!
	function evaluateXYZ( this, x, y, z ) result( output )
		class(NFunction3D), intent(in) :: this
		real(8), intent(in) :: x
		real(8), intent(in) :: y
		real(8), intent(in) :: z
		__TYPE_VALUE__ :: output
		
		integer :: ix, iy, iz
		
		! Map x,y,z to a point dx,dy,dz in the cube [1,n1] x [1,n2] x [1,n3]
		ix = floor( 1.0000001*(x-this.xyzGrid.min(1))/this.xyzGrid.stepSize(1)+1.0 )
		iy = floor( 1.0000001*(y-this.xyzGrid.min(2))/this.xyzGrid.stepSize(2)+1.0 )
		iz = floor( 1.0000001*(z-this.xyzGrid.min(3))/this.xyzGrid.stepSize(3)+1.0 )
		
		if( &
			ix < 1 .or. ix > this.xyzGrid.nPoints(1) .or. &
			iy < 1 .or. iy > this.xyzGrid.nPoints(2) .or. &
			iz < 1 .or. iz > this.xyzGrid.nPoints(3) &
		) then
			output = 0.0_8
		else
			output = this.fArray(ix,iy,iz)
		end if
	end function evaluateXYZ

	!>
	!! @brief
	!!
	function evaluateCoord( this, val, coord ) result( output )
		class(NFunction3D), intent(in) :: this
		real(8), intent(in) :: val
		integer, intent(in) :: coord
		__TYPE_VALUE__ :: output
		
		integer :: ival
		
		ival = floor( 1.0000001*(val-this.xyzGrid.min(coord))/this.xyzGrid.stepSize(coord)+1.0 )
		
		if( ival < 1 .or. ival > this.xyzGrid.nPoints(coord) ) then
			output = 0.0_8
		else
			select case( coord )
				case( 1 )
					output = sum(this.fArray(ival,:,:))
				case( 2 )
					output = sum(this.fArray(:,ival,:))
				case( 3 )
					output = sum(this.fArray(:,:,ival))
				case default
					write(*,*) "### ERROR ### NFunction3D.evaluateCoord() coord > 3"
					stop
			end select
		end if
	end function evaluateCoord
	
	!>
	!! @brief Resizes the function by making a larger grid with the same
	!!        step size by adding zeros at the end of each coordinate.
	!! @param nx Number of points to add in X coordinate
	!! @param ny Number of points to add in Y coordinate
	!! @param nz Number of points to add in Z coordinate
	!!
	subroutine resize( this, dnx, dny, dnz, dirx, diry, dirz )
		class(NFunction3D) :: this
		integer, intent(in) :: dnx, dny, dnz
		integer, optional, intent(in) :: dirx, diry, dirz
		
		integer :: effDirX, effDirY, effDirZ
		
		type(Grid3D) :: xyzGrid
		__TYPE_VALUE__, allocatable :: fArray(:,:,:)
		integer :: oldN(3)
		integer :: newN(3)
		integer :: i, j, k
		integer :: ii, jj, kk
		
		effDirX = 1
		if( present(dirx) ) effDirX = dirx
		
		effDirY = 1
		if( present(diry) ) effDirY = diry
		
		effDirZ = 1
		if( present(dirz) ) effDirZ = dirz
		
		xyzGrid = this.xyzGrid
		call xyzGrid.resize( dnx, dny, dnz, dirx, diry, dirz )
		
		oldN = this.xyzGrid.nPoints()
		
		if( effDirX == 1 .and. effDirY == 1 .and. effDirZ == 1 ) then
		
			newN = xyzGrid.nPoints()
			allocate( fArray(newN(1),newN(2),newN(3)) )
			fArray = 0.0_8
			
!$omp parallel private(k)
!$omp do schedule(dynamic,1)
			do k=1,oldN(3); do j=1,oldN(2); do i=1,oldN(1)
				fArray(i,j,k) = this.fArray(i,j,k)
			end do; end do; end do
!$omp end do nowait
!$omp end parallel

		else if( effDirX == -1 .and. effDirY == -1 .and. effDirZ == -1 ) then
		
			newN = xyzGrid.nPoints()
			allocate( fArray(newN(1),newN(2),newN(3)) )
			fArray = 0.0_8
			
!$omp parallel private(k)
!$omp do schedule(dynamic,1)
			do k=dnz+1,newN(3); do j=dny+1,newN(2); do i=dnx+1,newN(1)
				fArray(i,j,k) = this.fArray(i-dnx,j-dny,k-dnz)
			end do; end do; end do
!$omp end do nowait
!$omp end parallel
			
		else if( effDirX == 0 .and. effDirY == 0 .and. effDirZ == 0 ) then
			
			newN = xyzGrid.nPoints()
			allocate( fArray(newN(1),newN(2),newN(3)) )
			fArray = 0.0_8
			
			kk=1
			do k=dnz+1,dnz+oldN(3)
				jj=1
				do j=dny+1,dny+oldN(2)
					ii=1
					do i=dnx+1,dnx+oldN(1)
						fArray(i,j,k) = this.fArray(ii,jj,kk)
						ii=ii+1
					end do
					jj = jj+1
				end do
				kk = kk+1
			end do
			
		else
			call GOptions_error( &
				"Bad value for dir. (+1|0|-1)", &
				"NFunction3D.resize()" &
			)
		end if
		
		call this.init( xyzGrid, fArray )
		
		deallocate( fArray )
	end subroutine resize
	
	!>
	!! @brief
	!!
	function checkBox( this, other ) result( output )
		class(NFunction3D), intent(in) :: this
		class(NFunction3D), intent(in) :: other
		logical :: output
		
		output = this.xyzGrid.isEqualTo( other.xyzGrid )
	end function checkBox
	
	!>
	!! @brief
	!!
	function innerProductWithNFunction3D( this, other, hermitian ) result( output )
		class(NFunction3D), intent(in) :: this
		class(NFunction3D), intent(in) :: other
		logical, optional, intent(in) :: hermitian
		__TYPE_VALUE__ :: output
		
		logical :: effHermitian
		
		effHermitian = .true.
		if( present(hermitian) ) effHermitian = hermitian
		
! 		if( .not. this.xyzGrid.isEquallyspaced() ) then
! 			write(6,*) "### ERROR ### The grid is not equally spaced"
! 			stop
! 		end if
		
#if __ID_TYPE__ == 1
		if( effHermitian ) then
			output = sum( conjg(this.fArray)*other.fArray )*this.xyzGrid.dV()
		else
			output = sum( this.fArray*other.fArray )*this.xyzGrid.dV()
		end if
#else
		output = sum( this.fArray*other.fArray )*this.xyzGrid.dV()
#endif
	end function innerProductWithNFunction3D
	
	!>
	!! @brief
	!!
	function innerProductWithRArray( this, other, hermitian ) result( output )
		class(NFunction3D), intent(in) :: this
		real(8), intent(in) :: other(:,:,:)
		logical, optional, intent(in) :: hermitian
		__TYPE_VALUE__ :: output
		
		logical :: effHermitian
		
		effHermitian = .true.
		if( present(hermitian) ) effHermitian = hermitian
		
! 		if( .not. this.xyzGrid.isEquallyspaced() ) then
! 			write(6,*) "### ERROR ### The grid is not equally spaced"
! 			stop
! 		end if
		
#if __ID_TYPE__ == 1
		if( effHermitian ) then
			output = sum( conjg(this.fArray)*other )*this.xyzGrid.dV()
		else
			output = sum( this.fArray*other )*this.xyzGrid.dV()
		end if
#else
		output = sum( this.fArray*other )*this.xyzGrid.dV()
#endif
	end function innerProductWithRArray
	
	!>
	!! @brief
	!!
	function innerProductWithCArray( this, other, hermitian ) result( output )
		class(NFunction3D), intent(in) :: this
		complex(8), intent(in) :: other(:,:,:)
		logical, optional, intent(in) :: hermitian
		__TYPE_VALUE__ :: output
		
		logical :: effHermitian
		
		effHermitian = .true.
		if( present(hermitian) ) effHermitian = hermitian
		
! 		if( .not. this.xyzGrid.isEquallyspaced() ) then
! 			write(6,*) "### ERROR ### The grid is not equally spaced"
! 			stop
! 		end if
		
#if __ID_TYPE__ == 1
		if( effHermitian ) then
			output = sum( conjg(this.fArray)*other )*this.xyzGrid.dV()
		else
			output = sum( this.fArray*other )*this.xyzGrid.dV()
		end if
#else
		output = sum( this.fArray*other )*this.xyzGrid.dV()
#endif
	end function innerProductWithCArray
	
	!>
	!! @brief
	!!
	function conjugate( this ) result( output )
		class(NFunction3D), intent(in) :: this
		type(NFunction3D) :: output
		
		integer :: i, j, k
		
		output = this
		
#if __ID_TYPE__ == 1
!$omp parallel private(k)
!$omp do schedule(dynamic,1)
		do k=1,this.xyzGrid.nPoints(3); do j=1,this.xyzGrid.nPoints(2); do i=1,this.xyzGrid.nPoints(1)
			output.fArray(i,j,k) = conjg(this.fArray(i,j,k))
		end do; end do; end do
!$omp end do nowait
!$omp end parallel
#endif
	end function conjugate
	
	!>
	!! @brief
	!!
	function absoluteSquare( this ) result( output )
		class(NFunction3D), intent(in) :: this
		type(NFunction3D) :: output
		
		integer :: i, j, k
		
		output = this
		
#if __ID_TYPE__ == 1
!$omp parallel private(k)
!$omp do schedule(dynamic,1)
		do k=1,this.xyzGrid.nPoints(3); do j=1,this.xyzGrid.nPoints(2); do i=1,this.xyzGrid.nPoints(1)
			output.fArray(i,j,k) = abs(this.fArray(i,j,k))**2
		end do; end do; end do
!$omp end do nowait
!$omp end parallel
#else
!$omp parallel private(k)
!$omp do schedule(dynamic,1)
		do k=1,this.xyzGrid.nPoints(3); do j=1,this.xyzGrid.nPoints(2); do i=1,this.xyzGrid.nPoints(1)
			output.fArray(i,j,k) = this.fArray(i,j,k)**2
		end do; end do; end do
!$omp end do nowait
!$omp end parallel
#endif
	end function absoluteSquare
	
	!>
	!! @brief Returns the integration over all coordinates except "coord"
	!! @todo Esta función debería retornar una CNFunction o RNFunction
	!!       dependiendo de __TYPE_VALUE__, sin embargo, dado que solo
	!!       está implementada RNFunction ( actualmente NFunction ),
	!!       se tomará esta.
	!!
	function reducedFunction( this, coord ) result( output )
		class(NFunction3D), intent(in) :: this
		integer, optional, intent(in) :: coord
		type(RNFunction) :: output
		
		integer :: i
		real(8) :: dS
		real(8), allocatable :: cValues(:)
		integer :: id(3,2)
		
		if( .not. this.xyzGrid.isEquallyspaced() ) then
			write(6,*) "### ERROR ### The grid is not equally spaced"
			stop
		end if
		
		id(1,:) = [ 2, 3 ]
		id(2,:) = [ 1, 3 ]
		id(3,:) = [ 1, 2 ]
		
		dS = this.xyzGrid.stepSize( id(coord,1) )*this.xyzGrid.stepSize( id(coord,2) )
		
		allocate( cValues(this.xyzGrid.nPoints(coord)) )
		
		do i=1,this.xyzGrid.nPoints(coord)
			select case( coord )
				case( 1 )
					cValues(i) = sum(this.fArray(i,:,:))
				case( 2 )
					cValues(i) = sum(this.fArray(:,i,:))
				case( 3 )
					cValues(i) = sum(this.fArray(:,:,i))
				
				case default
					write(*,*) "### ERROR ### NFunction3D.reducedFunction() coord > 3"
					stop
			end select
		end do
		
		output = RNFunction( this.xyzGrid.component(coord), cValues*dS )
		
		deallocate( cValues )
		
	end function reducedFunction
	
#endif
